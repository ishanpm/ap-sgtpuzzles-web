/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/alpinejs/dist/module.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/alpinejs/dist/module.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Alpine\": () => (/* binding */ src_default),\n/* harmony export */   \"default\": () => (/* binding */ module_default)\n/* harmony export */ });\n// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\nvar lastFlushedIndex = -1;\nfunction scheduler(callback) {\n  queueJob(callback);\n}\nfunction queueJob(job) {\n  if (!queue.includes(job))\n    queue.push(job);\n  queueFlush();\n}\nfunction dequeueJob(job) {\n  let index = queue.indexOf(job);\n  if (index !== -1 && index > lastFlushedIndex)\n    queue.splice(index, 1);\n}\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n    lastFlushedIndex = i;\n  }\n  queue.length = 0;\n  lastFlushedIndex = -1;\n  flushing = false;\n}\n\n// packages/alpinejs/src/reactivity.js\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n  effect = (callback) => engine.effect(callback, { scheduler: (task) => {\n    if (shouldSchedule) {\n      scheduler(task);\n    } else {\n      task();\n    }\n  } });\n  raw = engine.raw;\n}\nfunction overrideEffect(override) {\n  effect = override;\n}\nfunction elementBoundEffect(el) {\n  let cleanup2 = () => {\n  };\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n    if (!el._x_effects) {\n      el._x_effects = /* @__PURE__ */ new Set();\n      el._x_runEffects = () => {\n        el._x_effects.forEach((i) => i());\n      };\n    }\n    el._x_effects.add(effectReference);\n    cleanup2 = () => {\n      if (effectReference === void 0)\n        return;\n      el._x_effects.delete(effectReference);\n      release(effectReference);\n    };\n    return effectReference;\n  };\n  return [wrappedEffect, () => {\n    cleanup2();\n  }];\n}\nfunction watch(getter, callback) {\n  let firstTime = true;\n  let oldValue;\n  let effectReference = effect(() => {\n    let value = getter();\n    JSON.stringify(value);\n    if (!firstTime) {\n      queueMicrotask(() => {\n        callback(value, oldValue);\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n    firstTime = false;\n  });\n  return () => release(effectReference);\n}\n\n// packages/alpinejs/src/mutation.js\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\nfunction onElRemoved(el, callback) {\n  if (typeof callback === \"function\") {\n    if (!el._x_cleanups)\n      el._x_cleanups = [];\n    el._x_cleanups.push(callback);\n  } else {\n    callback = el;\n    onElRemoveds.push(callback);\n  }\n}\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups)\n    el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name])\n    el._x_attributeCleanups[name] = [];\n  el._x_attributeCleanups[name].push(callback);\n}\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups)\n    return;\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n    if (names === void 0 || names.includes(name)) {\n      value.forEach((i) => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\nfunction cleanupElement(el) {\n  if (el._x_cleanups) {\n    while (el._x_cleanups.length)\n      el._x_cleanups.pop()();\n  }\n}\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\nfunction startObservingMutations() {\n  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });\n  currentlyObserving = true;\n}\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\nvar queuedMutations = [];\nfunction flushObserver() {\n  let records = observer.takeRecords();\n  queuedMutations.push(() => records.length > 0 && onMutate(records));\n  let queueLengthWhenTriggered = queuedMutations.length;\n  queueMicrotask(() => {\n    if (queuedMutations.length === queueLengthWhenTriggered) {\n      while (queuedMutations.length > 0)\n        queuedMutations.shift()();\n    }\n  });\n}\nfunction mutateDom(callback) {\n  if (!currentlyObserving)\n    return callback();\n  stopObservingMutations();\n  let result = callback();\n  startObservingMutations();\n  return result;\n}\nvar isCollecting = false;\nvar deferredMutations = [];\nfunction deferMutations() {\n  isCollecting = true;\n}\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n  let addedNodes = /* @__PURE__ */ new Set();\n  let removedNodes = /* @__PURE__ */ new Set();\n  let addedAttributes = /* @__PURE__ */ new Map();\n  let removedAttributes = /* @__PURE__ */ new Map();\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver)\n      continue;\n    if (mutations[i].type === \"childList\") {\n      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.add(node));\n      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.add(node));\n    }\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n      let add2 = () => {\n        if (!addedAttributes.has(el))\n          addedAttributes.set(el, []);\n        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });\n      };\n      let remove = () => {\n        if (!removedAttributes.has(el))\n          removedAttributes.set(el, []);\n        removedAttributes.get(el).push(name);\n      };\n      if (el.hasAttribute(name) && oldValue === null) {\n        add2();\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add2();\n      } else {\n        remove();\n      }\n    }\n  }\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n  for (let node of removedNodes) {\n    if (addedNodes.has(node))\n      continue;\n    onElRemoveds.forEach((i) => i(node));\n  }\n  addedNodes.forEach((node) => {\n    node._x_ignoreSelf = true;\n    node._x_ignore = true;\n  });\n  for (let node of addedNodes) {\n    if (removedNodes.has(node))\n      continue;\n    if (!node.isConnected)\n      continue;\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n    onElAddeds.forEach((i) => i(node));\n    node._x_ignore = true;\n    node._x_ignoreSelf = true;\n  }\n  addedNodes.forEach((node) => {\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n  });\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n\n// packages/alpinejs/src/scope.js\nfunction scope(node) {\n  return mergeProxies(closestDataStack(node));\n}\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\n  };\n}\nfunction closestDataStack(node) {\n  if (node._x_dataStack)\n    return node._x_dataStack;\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n  if (!node.parentNode) {\n    return [];\n  }\n  return closestDataStack(node.parentNode);\n}\nfunction mergeProxies(objects) {\n  return new Proxy({ objects }, mergeProxyTrap);\n}\nvar mergeProxyTrap = {\n  ownKeys({ objects }) {\n    return Array.from(\n      new Set(objects.flatMap((i) => Object.keys(i)))\n    );\n  },\n  has({ objects }, name) {\n    if (name == Symbol.unscopables)\n      return false;\n    return objects.some(\n      (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)\n    );\n  },\n  get({ objects }, name, thisProxy) {\n    if (name == \"toJSON\")\n      return collapseProxies;\n    return Reflect.get(\n      objects.find(\n        (obj) => Reflect.has(obj, name)\n      ) || {},\n      name,\n      thisProxy\n    );\n  },\n  set({ objects }, name, value, thisProxy) {\n    const target = objects.find(\n      (obj) => Object.prototype.hasOwnProperty.call(obj, name)\n    ) || objects[objects.length - 1];\n    const descriptor = Object.getOwnPropertyDescriptor(target, name);\n    if (descriptor?.set && descriptor?.get)\n      return descriptor.set.call(thisProxy, value) || true;\n    return Reflect.set(target, name, value);\n  }\n};\nfunction collapseProxies() {\n  let keys = Reflect.ownKeys(this);\n  return keys.reduce((acc, key) => {\n    acc[key] = Reflect.get(this, key);\n    return acc;\n  }, {});\n}\n\n// packages/alpinejs/src/interceptor.js\nfunction initInterceptors(data2) {\n  let isObject2 = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\n  let recurse = (obj, basePath = \"\") => {\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {\n      if (enumerable === false || value === void 0)\n        return;\n      if (typeof value === \"object\" && value !== null && value.__v_skip)\n        return;\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject2(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n  return recurse(data2);\n}\nfunction interceptor(callback, mutateObj = () => {\n}) {\n  let obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\n    }\n  };\n  mutateObj(obj);\n  return (initialValue) => {\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\n      let initialize = obj.initialize.bind(obj);\n      obj.initialize = (data2, path, key) => {\n        let innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n    return obj;\n  };\n}\nfunction get(obj, path) {\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\n}\nfunction set(obj, path, value) {\n  if (typeof path === \"string\")\n    path = path.split(\".\");\n  if (path.length === 1)\n    obj[path[0]] = value;\n  else if (path.length === 0)\n    throw error;\n  else {\n    if (obj[path[0]])\n      return set(obj[path[0]], path.slice(1), value);\n    else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n}\n\n// packages/alpinejs/src/magics.js\nvar magics = {};\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\nfunction injectMagics(obj, el) {\n  Object.entries(magics).forEach(([name, callback]) => {\n    let memoizedUtilities = null;\n    function getUtilities() {\n      if (memoizedUtilities) {\n        return memoizedUtilities;\n      } else {\n        let [utilities, cleanup2] = getElementBoundUtilities(el);\n        memoizedUtilities = { interceptor, ...utilities };\n        onElRemoved(el, cleanup2);\n        return memoizedUtilities;\n      }\n    }\n    Object.defineProperty(obj, `$${name}`, {\n      get() {\n        return callback(el, getUtilities());\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/utils/error.js\nfunction tryCatch(el, expression, callback, ...args) {\n  try {\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\nfunction handleError(error2, el, expression = void 0) {\n  error2 = Object.assign(\n    error2 ?? { message: \"No error message given.\" },\n    { el, expression }\n  );\n  console.warn(`Alpine Expression Error: ${error2.message}\n\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n}\n\n// packages/alpinejs/src/evaluator.js\nvar shouldAutoEvaluateFunctions = true;\nfunction dontAutoEvaluateFunctions(callback) {\n  let cache = shouldAutoEvaluateFunctions;\n  shouldAutoEvaluateFunctions = false;\n  let result = callback();\n  shouldAutoEvaluateFunctions = cache;\n  return result;\n}\nfunction evaluate(el, expression, extras = {}) {\n  let result;\n  evaluateLater(el, expression)((value) => result = value, extras);\n  return result;\n}\nfunction evaluateLater(...args) {\n  return theEvaluatorFunction(...args);\n}\nvar theEvaluatorFunction = normalEvaluator;\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\nfunction normalEvaluator(el, expression) {\n  let overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\n  let evaluator = typeof expression === \"function\" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\nvar evaluatorMemo = {};\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n  let AsyncFunction = Object.getPrototypeOf(async function() {\n  }).constructor;\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression.trim()) || /^(let|const)\\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;\n  const safeAsyncFunction = () => {\n    try {\n      let func2 = new AsyncFunction(\n        [\"__self\", \"scope\"],\n        `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`\n      );\n      Object.defineProperty(func2, \"name\", {\n        value: `[Alpine] ${expression}`\n      });\n      return func2;\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n  let func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  let func = generateFunctionFromString(expression, el);\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    func.result = void 0;\n    func.finished = false;\n    let completeScope = mergeProxies([scope2, ...dataStack]);\n    if (typeof func === \"function\") {\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then((result) => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\nfunction runIfTypeOfFunction(receiver, value, scope2, params, el) {\n  if (shouldAutoEvaluateFunctions && typeof value === \"function\") {\n    let result = value.apply(scope2, params);\n    if (result instanceof Promise) {\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else if (typeof value === \"object\" && value instanceof Promise) {\n    value.then((i) => receiver(i));\n  } else {\n    receiver(value);\n  }\n}\n\n// packages/alpinejs/src/directives.js\nvar prefixAsString = \"x-\";\nfunction prefix(subject = \"\") {\n  return prefixAsString + subject;\n}\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\nvar directiveHandlers = {};\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n  return {\n    before(directive2) {\n      if (!directiveHandlers[directive2]) {\n        console.warn(String.raw`Cannot find directive \\`${directive2}\\`. \\`${name}\\` will use the default order of execution`);\n        return;\n      }\n      const pos = directiveOrder.indexOf(directive2);\n      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf(\"DEFAULT\"), 0, name);\n    }\n  };\n}\nfunction directiveExists(name) {\n  return Object.keys(directiveHandlers).includes(name);\n}\nfunction directives(el, attributes, originalAttributeOverride) {\n  attributes = Array.from(attributes);\n  if (el._x_virtualDirectives) {\n    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));\n    let staticAttributes = attributesOnly(vAttributes);\n    vAttributes = vAttributes.map((attribute) => {\n      if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n        return {\n          name: `x-bind:${attribute.name}`,\n          value: `\"${attribute.value}\"`\n        };\n      }\n      return attribute;\n    });\n    attributes = attributes.concat(vAttributes);\n  }\n  let transformedAttributeMap = {};\n  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map((directive2) => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\n}\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = /* @__PURE__ */ new Map();\nvar currentHandlerStackKey = Symbol();\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  let key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length)\n      directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n  callback(flushHandlers);\n  stopDeferring();\n}\nfunction getElementBoundUtilities(el) {\n  let cleanups = [];\n  let cleanup2 = (callback) => cleanups.push(callback);\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  let utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup: cleanup2,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n  let doCleanup = () => cleanups.forEach((i) => i());\n  return [utilities, doCleanup];\n}\nfunction getDirectiveHandler(el, directive2) {\n  let noop = () => {\n  };\n  let handler4 = directiveHandlers[directive2.type] || noop;\n  let [utilities, cleanup2] = getElementBoundUtilities(el);\n  onAttributeRemoved(el, directive2.original, cleanup2);\n  let fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf)\n      return;\n    handler4.inline && handler4.inline(el, directive2, utilities);\n    handler4 = handler4.bind(handler4, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();\n  };\n  fullHandler.runCleanups = cleanup2;\n  return fullHandler;\n}\nvar startingWith = (subject, replacement) => ({ name, value }) => {\n  if (name.startsWith(subject))\n    name = name.replace(subject, replacement);\n  return { name, value };\n};\nvar into = (i) => i;\nfunction toTransformedAttributes(callback = () => {\n}) {\n  return ({ name, value }) => {\n    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, { name, value });\n    if (newName !== name)\n      callback(newName, name);\n    return { name: newName, value: newValue };\n  };\n}\nvar attributeTransformers = [];\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\nfunction outNonAlpineAttributes({ name }) {\n  return alpineAttributeRegex().test(name);\n}\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return ({ name, value }) => {\n    let typeMatch = name.match(alpineAttributeRegex());\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-_:]+)/);\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\n      expression: value,\n      original\n    };\n  };\n}\nvar DEFAULT = \"DEFAULT\";\nvar directiveOrder = [\n  \"ignore\",\n  \"ref\",\n  \"data\",\n  \"id\",\n  \"anchor\",\n  \"bind\",\n  \"init\",\n  \"for\",\n  \"model\",\n  \"modelable\",\n  \"transition\",\n  \"show\",\n  \"if\",\n  DEFAULT,\n  \"teleport\"\n];\nfunction byPriority(a, b) {\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n}\n\n// packages/alpinejs/src/utils/dispatch.js\nfunction dispatch(el, name, detail = {}) {\n  el.dispatchEvent(\n    new CustomEvent(name, {\n      detail,\n      bubbles: true,\n      // Allows events to pass the shadow DOM barrier.\n      composed: true,\n      cancelable: true\n    })\n  );\n}\n\n// packages/alpinejs/src/utils/walk.js\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\n    return;\n  }\n  let skip = false;\n  callback(el, () => skip = true);\n  if (skip)\n    return;\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\n// packages/alpinejs/src/utils/warn.js\nfunction warn(message, ...args) {\n  console.warn(`Alpine Warning: ${message}`, ...args);\n}\n\n// packages/alpinejs/src/lifecycle.js\nvar started = false;\nfunction start() {\n  if (started)\n    warn(\"Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.\");\n  started = true;\n  if (!document.body)\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\n  dispatch(document, \"alpine:init\");\n  dispatch(document, \"alpine:initializing\");\n  startObservingMutations();\n  onElAdded((el) => initTree(el, walk));\n  onElRemoved((el) => destroyTree(el));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach((handle) => handle());\n  });\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\n  Array.from(document.querySelectorAll(allSelectors().join(\",\"))).filter(outNestedComponents).forEach((el) => {\n    initTree(el);\n  });\n  dispatch(document, \"alpine:initialized\");\n  setTimeout(() => {\n    warnAboutMissingPlugins();\n  });\n}\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map((fn) => fn());\n}\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\n}\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\nfunction closestRoot(el, includeInitSelectors = false) {\n  return findClosest(el, (element) => {\n    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n    if (selectors.some((selector) => element.matches(selector)))\n      return true;\n  });\n}\nfunction findClosest(el, callback) {\n  if (!el)\n    return;\n  if (callback(el))\n    return el;\n  if (el._x_teleportBack)\n    el = el._x_teleportBack;\n  if (!el.parentElement)\n    return;\n  return findClosest(el.parentElement, callback);\n}\nfunction isRoot(el) {\n  return rootSelectors().some((selector) => el.matches(selector));\n}\nvar initInterceptors2 = [];\nfunction interceptInit(callback) {\n  initInterceptors2.push(callback);\n}\nfunction initTree(el, walker = walk, intercept = () => {\n}) {\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      intercept(el2, skip);\n      initInterceptors2.forEach((i) => i(el2, skip));\n      directives(el2, el2.attributes).forEach((handle) => handle());\n      el2._x_ignore && skip();\n    });\n  });\n}\nfunction destroyTree(root, walker = walk) {\n  walker(root, (el) => {\n    cleanupAttributes(el);\n    cleanupElement(el);\n  });\n}\nfunction warnAboutMissingPlugins() {\n  let pluginDirectives = [\n    [\"ui\", \"dialog\", [\"[x-dialog], [x-popover]\"]],\n    [\"anchor\", \"anchor\", [\"[x-anchor]\"]],\n    [\"sort\", \"sort\", [\"[x-sort]\"]]\n  ];\n  pluginDirectives.forEach(([plugin2, directive2, selectors]) => {\n    if (directiveExists(directive2))\n      return;\n    selectors.some((selector) => {\n      if (document.querySelector(selector)) {\n        warn(`found \"${selector}\", but missing ${plugin2} plugin`);\n        return true;\n      }\n    });\n  });\n}\n\n// packages/alpinejs/src/nextTick.js\nvar tickStack = [];\nvar isHolding = false;\nfunction nextTick(callback = () => {\n}) {\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n  return new Promise((res) => {\n    tickStack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\nfunction releaseNextTicks() {\n  isHolding = false;\n  while (tickStack.length)\n    tickStack.shift()();\n}\nfunction holdNextTicks() {\n  isHolding = true;\n}\n\n// packages/alpinejs/src/utils/classes.js\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === \"function\") {\n    return setClasses(el, value());\n  }\n  return setClassesFromString(el, value);\n}\nfunction setClassesFromString(el, classString) {\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\n  let addClassesAndReturnUndo = (classes) => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n  classString = classString === true ? classString = \"\" : classString || \"\";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\n  let added = [];\n  let removed = [];\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n\n// packages/alpinejs/src/utils/styles.js\nfunction setStyles(el, value) {\n  if (typeof value === \"object\" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n  return setStylesFromString(el, value);\n}\nfunction setStylesFromObject(el, value) {\n  let previousStyles = {};\n  Object.entries(value).forEach(([key, value2]) => {\n    previousStyles[key] = el.style[key];\n    if (!key.startsWith(\"--\")) {\n      key = kebabCase(key);\n    }\n    el.style.setProperty(key, value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\nfunction setStylesFromString(el, value) {\n  let cache = el.getAttribute(\"style\", value);\n  el.setAttribute(\"style\", value);\n  return () => {\n    el.setAttribute(\"style\", cache || \"\");\n  };\n}\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// packages/alpinejs/src/utils/once.js\nfunction once(callback, fallback = () => {\n}) {\n  let called = false;\n  return function() {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n}\n\n// packages/alpinejs/src/directives/x-transition.js\ndirective(\"transition\", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"function\")\n    expression = evaluate2(expression);\n  if (expression === false)\n    return;\n  if (!expression || typeof expression === \"boolean\") {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, \"\");\n  let directiveStorageMap = {\n    \"enter\": (classes) => {\n      el._x_transition.enter.during = classes;\n    },\n    \"enter-start\": (classes) => {\n      el._x_transition.enter.start = classes;\n    },\n    \"enter-end\": (classes) => {\n      el._x_transition.enter.end = classes;\n    },\n    \"leave\": (classes) => {\n      el._x_transition.leave.during = classes;\n    },\n    \"leave-start\": (classes) => {\n      el._x_transition.leave.start = classes;\n    },\n    \"leave-end\": (classes) => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\n  }\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\n  }\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\n  let opacityValue = wantsOpacity ? 0 : 1;\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\n  let delay = modifierValue(modifiers, \"delay\", 0) / 1e3;\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\n  let property = \"opacity, transform\";\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationIn}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n  }\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationOut}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n  }\n}\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n  if (!el._x_transition)\n    el._x_transition = {\n      enter: { during: defaultValue, start: defaultValue, end: defaultValue },\n      leave: { during: defaultValue, start: defaultValue, end: defaultValue },\n      in(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.enter.during,\n          start: this.enter.start,\n          end: this.enter.end\n        }, before, after);\n      },\n      out(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.leave.during,\n          start: this.leave.start,\n          end: this.leave.end\n        }, before, after);\n      }\n    };\n}\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\n  const nextTick2 = document.visibilityState === \"visible\" ? requestAnimationFrame : setTimeout;\n  let clickAwayCompatibleShow = () => nextTick2(show);\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n    return;\n  }\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {\n    }, () => resolve(hide));\n    el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    let closest = closestHide(el);\n    if (closest) {\n      if (!closest._x_hideChildren)\n        closest._x_hideChildren = [];\n      closest._x_hideChildren.push(el);\n    } else {\n      nextTick2(() => {\n        let hideAfterChildren = (el2) => {\n          let carry = Promise.all([\n            el2._x_hidePromise,\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\n          ]).then(([i]) => i?.());\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n        hideAfterChildren(el).catch((e) => {\n          if (!e.isFromCancelledTransition)\n            throw e;\n        });\n      });\n    }\n  });\n};\nfunction closestHide(el) {\n  let parent = el.parentNode;\n  if (!parent)\n    return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\nfunction transition(el, setFunction, { during, start: start2, end } = {}, before = () => {\n}, after = () => {\n}) {\n  if (el._x_transitioning)\n    el._x_transitioning.cancel();\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n  let undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n    before,\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n    after,\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n  });\n}\nfunction performTransition(el, stages) {\n  let interrupted, reachedBefore, reachedEnd;\n  let finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore)\n        stages.before();\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n      stages.after();\n      if (el.isConnected)\n        stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n    cancel: once(function() {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted)\n      return;\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    if (duration === 0)\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted)\n        return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1)\n    return fallback;\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue)\n    return fallback;\n  if (key === \"scale\") {\n    if (isNaN(rawValue))\n      return fallback;\n  }\n  if (key === \"duration\" || key === \"delay\") {\n    let match = rawValue.match(/([0-9]+)ms/);\n    if (match)\n      return match[1];\n  }\n  if (key === \"origin\") {\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\n    }\n  }\n  return rawValue;\n}\n\n// packages/alpinejs/src/clone.js\nvar isCloning = false;\nfunction skipDuringClone(callback, fallback = () => {\n}) {\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\n}\nfunction onlyDuringClone(callback) {\n  return (...args) => isCloning && callback(...args);\n}\nvar interceptors = [];\nfunction interceptClone(callback) {\n  interceptors.push(callback);\n}\nfunction cloneNode(from, to) {\n  interceptors.forEach((i) => i(from, to));\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    initTree(to, (el, callback) => {\n      callback(el, () => {\n      });\n    });\n  });\n  isCloning = false;\n}\nvar isCloningLegacy = false;\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack)\n    newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  isCloningLegacy = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n  isCloningLegacy = false;\n}\nfunction cloneTree(el) {\n  let hasRunThroughFirstEl = false;\n  let shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3))\n        return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n  initTree(el, shallowWalker);\n}\nfunction dontRegisterReactiveSideEffects(callback) {\n  let cache = effect;\n  overrideEffect((callback2, el) => {\n    let storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {\n    };\n  });\n  callback();\n  overrideEffect(cache);\n}\n\n// packages/alpinejs/src/utils/bind.js\nfunction bind(el, name, value, modifiers = []) {\n  if (!el._x_bindings)\n    el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\n  switch (name) {\n    case \"value\":\n      bindInputValue(el, value);\n      break;\n    case \"style\":\n      bindStyles(el, value);\n      break;\n    case \"class\":\n      bindClasses(el, value);\n      break;\n    case \"selected\":\n    case \"checked\":\n      bindAttributeAndProperty(el, name, value);\n      break;\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\nfunction bindInputValue(el, value) {\n  if (el.type === \"radio\") {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n    if (window.fromModel) {\n      if (typeof value === \"boolean\") {\n        el.checked = safeParseBoolean(el.value) === value;\n      } else {\n        el.checked = checkedAttrLooseCompare(el.value, value);\n      }\n    }\n  } else if (el.type === \"checkbox\") {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === \"SELECT\") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value)\n      return;\n    el.value = value === void 0 ? \"\" : value;\n  }\n}\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses)\n    el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles)\n    el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\nfunction bindAttributeAndProperty(el, name, value) {\n  bindAttribute(el, name, value);\n  setPropertyIfChanged(el, name, value);\n}\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name))\n      value = name;\n    setIfChanged(el, name, value);\n  }\n}\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\nfunction setPropertyIfChanged(el, propName, value) {\n  if (el[propName] !== value) {\n    el[propName] = value;\n  }\n}\nfunction updateSelect(el, value) {\n  const arrayWrappedValue = [].concat(value).map((value2) => {\n    return value2 + \"\";\n  });\n  Array.from(el.options).forEach((option) => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction safeParseBoolean(rawValue) {\n  if ([1, \"1\", \"true\", \"on\", \"yes\", true].includes(rawValue)) {\n    return true;\n  }\n  if ([0, \"0\", \"false\", \"off\", \"no\", false].includes(rawValue)) {\n    return false;\n  }\n  return rawValue ? Boolean(rawValue) : null;\n}\nfunction isBooleanAttr(attrName) {\n  const booleanAttributes = [\n    \"disabled\",\n    \"checked\",\n    \"required\",\n    \"readonly\",\n    \"open\",\n    \"selected\",\n    \"autofocus\",\n    \"itemscope\",\n    \"multiple\",\n    \"novalidate\",\n    \"allowfullscreen\",\n    \"allowpaymentrequest\",\n    \"formnovalidate\",\n    \"autoplay\",\n    \"controls\",\n    \"loop\",\n    \"muted\",\n    \"playsinline\",\n    \"default\",\n    \"ismap\",\n    \"reversed\",\n    \"async\",\n    \"defer\",\n    \"nomodule\"\n  ];\n  return booleanAttributes.includes(attrName);\n}\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"].includes(name);\n}\nfunction getBinding(el, name, fallback) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  return getAttributeBinding(el, name, fallback);\n}\nfunction extractProp(el, name, fallback, extract = true) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {\n    let binding = el._x_inlineBindings[name];\n    binding.extract = extract;\n    return dontAutoEvaluateFunctions(() => {\n      return evaluate(el, binding.expression);\n    });\n  }\n  return getAttributeBinding(el, name, fallback);\n}\nfunction getAttributeBinding(el, name, fallback) {\n  let attr = el.getAttribute(name);\n  if (attr === null)\n    return typeof fallback === \"function\" ? fallback() : fallback;\n  if (attr === \"\")\n    return true;\n  if (isBooleanAttr(name)) {\n    return !![name, \"true\"].includes(attr);\n  }\n  return attr;\n}\n\n// packages/alpinejs/src/utils/debounce.js\nfunction debounce(func, wait) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// packages/alpinejs/src/utils/throttle.js\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    let context = this, args = arguments;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// packages/alpinejs/src/entangle.js\nfunction entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {\n  let firstRun = true;\n  let outerHash;\n  let innerHash;\n  let reference = effect(() => {\n    let outer = outerGet();\n    let inner = innerGet();\n    if (firstRun) {\n      innerSet(cloneIfObject(outer));\n      firstRun = false;\n    } else {\n      let outerHashLatest = JSON.stringify(outer);\n      let innerHashLatest = JSON.stringify(inner);\n      if (outerHashLatest !== outerHash) {\n        innerSet(cloneIfObject(outer));\n      } else if (outerHashLatest !== innerHashLatest) {\n        outerSet(cloneIfObject(inner));\n      } else {\n      }\n    }\n    outerHash = JSON.stringify(outerGet());\n    innerHash = JSON.stringify(innerGet());\n  });\n  return () => {\n    release(reference);\n  };\n}\nfunction cloneIfObject(value) {\n  return typeof value === \"object\" ? JSON.parse(JSON.stringify(value)) : value;\n}\n\n// packages/alpinejs/src/plugin.js\nfunction plugin(callback) {\n  let callbacks = Array.isArray(callback) ? callback : [callback];\n  callbacks.forEach((i) => i(alpine_default));\n}\n\n// packages/alpinejs/src/store.js\nvar stores = {};\nvar isReactive = false;\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n  if (value === void 0) {\n    return stores[name];\n  }\n  stores[name] = value;\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\n    stores[name].init();\n  }\n  initInterceptors(stores[name]);\n}\nfunction getStores() {\n  return stores;\n}\n\n// packages/alpinejs/src/binds.js\nvar binds = {};\nfunction bind2(name, bindings) {\n  let getBindings = typeof bindings !== \"function\" ? () => bindings : bindings;\n  if (name instanceof Element) {\n    return applyBindingsObject(name, getBindings());\n  } else {\n    binds[name] = getBindings;\n  }\n  return () => {\n  };\n}\nfunction injectBindingProviders(obj) {\n  Object.entries(binds).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback(...args);\n        };\n      }\n    });\n  });\n  return obj;\n}\nfunction applyBindingsObject(el, obj, original) {\n  let cleanupRunners = [];\n  while (cleanupRunners.length)\n    cleanupRunners.pop()();\n  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));\n  let staticAttributes = attributesOnly(attributes);\n  attributes = attributes.map((attribute) => {\n    if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n      return {\n        name: `x-bind:${attribute.name}`,\n        value: `\"${attribute.value}\"`\n      };\n    }\n    return attribute;\n  });\n  directives(el, attributes, original).map((handle) => {\n    cleanupRunners.push(handle.runCleanups);\n    handle();\n  });\n  return () => {\n    while (cleanupRunners.length)\n      cleanupRunners.pop()();\n  };\n}\n\n// packages/alpinejs/src/datas.js\nvar datas = {};\nfunction data(name, callback) {\n  datas[name] = callback;\n}\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback.bind(context)(...args);\n        };\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/alpine.js\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n  get release() {\n    return release;\n  },\n  get effect() {\n    return effect;\n  },\n  get raw() {\n    return raw;\n  },\n  version: \"3.14.1\",\n  flushAndStopDeferringMutations,\n  dontAutoEvaluateFunctions,\n  disableEffectScheduling,\n  startObservingMutations,\n  stopObservingMutations,\n  setReactivityEngine,\n  onAttributeRemoved,\n  onAttributesAdded,\n  closestDataStack,\n  skipDuringClone,\n  onlyDuringClone,\n  addRootSelector,\n  addInitSelector,\n  interceptClone,\n  addScopeToNode,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  interceptInit,\n  setEvaluator,\n  mergeProxies,\n  extractProp,\n  findClosest,\n  onElRemoved,\n  closestRoot,\n  destroyTree,\n  interceptor,\n  // INTERNAL: not public API and is subject to change without major release.\n  transition,\n  // INTERNAL\n  setStyles,\n  // INTERNAL\n  mutateDom,\n  directive,\n  entangle,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefixed: prefix,\n  prefix: setPrefix,\n  plugin,\n  magic,\n  store,\n  start,\n  clone,\n  // INTERNAL\n  cloneNode,\n  // INTERNAL\n  bound: getBinding,\n  $data: scope,\n  watch,\n  walk,\n  data,\n  bind: bind2\n};\nvar alpine_default = Alpine;\n\n// node_modules/@vue/shared/dist/shared.esm-bundler.js\nfunction makeMap(str, expectsLowerCase) {\n  const map = /* @__PURE__ */ Object.create(null);\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n}\nvar specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nvar isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\nvar EMPTY_OBJ =  true ? Object.freeze({}) : 0;\nvar EMPTY_ARR =  true ? Object.freeze([]) : 0;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hasOwn = (val, key) => hasOwnProperty.call(val, key);\nvar isArray = Array.isArray;\nvar isMap = (val) => toTypeString(val) === \"[object Map]\";\nvar isString = (val) => typeof val === \"string\";\nvar isSymbol = (val) => typeof val === \"symbol\";\nvar isObject = (val) => val !== null && typeof val === \"object\";\nvar objectToString = Object.prototype.toString;\nvar toTypeString = (value) => objectToString.call(value);\nvar toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nvar isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nvar cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nvar capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\nvar toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\nvar hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n\n// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\nvar targetMap = /* @__PURE__ */ new WeakMap();\nvar effectStack = [];\nvar activeEffect;\nvar ITERATE_KEY = Symbol( true ? \"iterate\" : 0);\nvar MAP_KEY_ITERATE_KEY = Symbol( true ? \"Map key iterate\" : 0);\nfunction isEffect(fn) {\n  return fn && fn._isEffect === true;\n}\nfunction effect2(fn, options = EMPTY_OBJ) {\n  if (isEffect(fn)) {\n    fn = fn.raw;\n  }\n  const effect3 = createReactiveEffect(fn, options);\n  if (!options.lazy) {\n    effect3();\n  }\n  return effect3;\n}\nfunction stop(effect3) {\n  if (effect3.active) {\n    cleanup(effect3);\n    if (effect3.options.onStop) {\n      effect3.options.onStop();\n    }\n    effect3.active = false;\n  }\n}\nvar uid = 0;\nfunction createReactiveEffect(fn, options) {\n  const effect3 = function reactiveEffect() {\n    if (!effect3.active) {\n      return fn();\n    }\n    if (!effectStack.includes(effect3)) {\n      cleanup(effect3);\n      try {\n        enableTracking();\n        effectStack.push(effect3);\n        activeEffect = effect3;\n        return fn();\n      } finally {\n        effectStack.pop();\n        resetTracking();\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  };\n  effect3.id = uid++;\n  effect3.allowRecurse = !!options.allowRecurse;\n  effect3._isEffect = true;\n  effect3.active = true;\n  effect3.raw = fn;\n  effect3.deps = [];\n  effect3.options = options;\n  return effect3;\n}\nfunction cleanup(effect3) {\n  const { deps } = effect3;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect3);\n    }\n    deps.length = 0;\n  }\n}\nvar shouldTrack = true;\nvar trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (!shouldTrack || activeEffect === void 0) {\n    return;\n  }\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, dep = /* @__PURE__ */ new Set());\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (activeEffect.options.onTrack) {\n      activeEffect.options.onTrack({\n        effect: activeEffect,\n        target,\n        type,\n        key\n      });\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  const effects = /* @__PURE__ */ new Set();\n  const add2 = (effectsToAdd) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach((effect3) => {\n        if (effect3 !== activeEffect || effect3.allowRecurse) {\n          effects.add(effect3);\n        }\n      });\n    }\n  };\n  if (type === \"clear\") {\n    depsMap.forEach(add2);\n  } else if (key === \"length\" && isArray(target)) {\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newValue) {\n        add2(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      add2(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          add2(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const run = (effect3) => {\n    if (effect3.options.onTrigger) {\n      effect3.options.onTrigger({\n        effect: effect3,\n        target,\n        key,\n        type,\n        newValue,\n        oldValue,\n        oldTarget\n      });\n    }\n    if (effect3.options.scheduler) {\n      effect3.options.scheduler(effect3);\n    } else {\n      effect3();\n    }\n  };\n  effects.forEach(run);\n}\nvar isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nvar builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));\nvar get2 = /* @__PURE__ */ createGetter();\nvar readonlyGet = /* @__PURE__ */ createGetter(true);\nvar arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get3(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive2(res);\n    }\n    return res;\n  };\n}\nvar set2 = /* @__PURE__ */ createSetter();\nfunction createSetter(shallow = false) {\n  return function set3(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!shallow) {\n      value = toRaw(value);\n      oldValue = toRaw(oldValue);\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nvar mutableHandlers = {\n  get: get2,\n  set: set2,\n  deleteProperty,\n  has,\n  ownKeys\n};\nvar readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (true) {\n      console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (true) {\n      console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n};\nvar toReactive = (value) => isObject(value) ? reactive2(value) : value;\nvar toReadonly = (value) => isObject(value) ? readonly(value) : value;\nvar toShallow = (value) => value;\nvar getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n  target = target[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"get\", key);\n  }\n  !isReadonly && track(rawTarget, \"get\", rawKey);\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has$1(key, isReadonly = false) {\n  const target = this[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"has\", key);\n  }\n  !isReadonly && track(rawTarget, \"has\", rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set$1(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get3 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get3.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get3 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get3 ? get3.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget =  true ? isMap(target) ? new Map(target) : new Set(target) : 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\n      \"__v_raw\"\n      /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\n      \"__v_raw\"\n      /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (true) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get$1(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\n      \"add\"\n      /* ADD */\n    ),\n    set: createReadonlyMethod(\n      \"set\"\n      /* SET */\n    ),\n    delete: createReadonlyMethod(\n      \"delete\"\n      /* DELETE */\n    ),\n    clear: createReadonlyMethod(\n      \"clear\"\n      /* CLEAR */\n    ),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\n      \"add\"\n      /* ADD */\n    ),\n    set: createReadonlyMethod(\n      \"set\"\n      /* SET */\n    ),\n    delete: createReadonlyMethod(\n      \"delete\"\n      /* DELETE */\n    ),\n    clear: createReadonlyMethod(\n      \"clear\"\n      /* CLEAR */\n    ),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nvar [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nvar mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nvar readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\nvar reactiveMap = /* @__PURE__ */ new WeakMap();\nvar shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nvar readonlyMap = /* @__PURE__ */ new WeakMap();\nvar shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction getTargetType(value) {\n  return value[\n    \"__v_skip\"\n    /* SKIP */\n  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));\n}\nfunction reactive2(target) {\n  if (target && target[\n    \"__v_isReadonly\"\n    /* IS_READONLY */\n  ]) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (true) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\n    \"__v_raw\"\n    /* RAW */\n  ] && !(isReadonly && target[\n    \"__v_isReactive\"\n    /* IS_REACTIVE */\n  ])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction toRaw(observed) {\n  return observed && toRaw(observed[\n    \"__v_raw\"\n    /* RAW */\n  ]) || observed;\n}\nfunction isRef(r) {\n  return Boolean(r && r.__v_isRef === true);\n}\n\n// packages/alpinejs/src/magics/$nextTick.js\nmagic(\"nextTick\", () => nextTick);\n\n// packages/alpinejs/src/magics/$dispatch.js\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\n\n// packages/alpinejs/src/magics/$watch.js\nmagic(\"watch\", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {\n  let evaluate2 = evaluateLater2(key);\n  let getter = () => {\n    let value;\n    evaluate2((i) => value = i);\n    return value;\n  };\n  let unwatch = watch(getter, callback);\n  cleanup2(unwatch);\n});\n\n// packages/alpinejs/src/magics/$store.js\nmagic(\"store\", getStores);\n\n// packages/alpinejs/src/magics/$data.js\nmagic(\"data\", (el) => scope(el));\n\n// packages/alpinejs/src/magics/$root.js\nmagic(\"root\", (el) => closestRoot(el));\n\n// packages/alpinejs/src/magics/$refs.js\nmagic(\"refs\", (el) => {\n  if (el._x_refs_proxy)\n    return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\nfunction getArrayOfRefObject(el) {\n  let refObjects = [];\n  findClosest(el, (i) => {\n    if (i._x_refs)\n      refObjects.push(i._x_refs);\n  });\n  return refObjects;\n}\n\n// packages/alpinejs/src/ids.js\nvar globalIdMemo = {};\nfunction findAndIncrementId(name) {\n  if (!globalIdMemo[name])\n    globalIdMemo[name] = 0;\n  return ++globalIdMemo[name];\n}\nfunction closestIdRoot(el, name) {\n  return findClosest(el, (element) => {\n    if (element._x_ids && element._x_ids[name])\n      return true;\n  });\n}\nfunction setIdRoot(el, name) {\n  if (!el._x_ids)\n    el._x_ids = {};\n  if (!el._x_ids[name])\n    el._x_ids[name] = findAndIncrementId(name);\n}\n\n// packages/alpinejs/src/magics/$id.js\nmagic(\"id\", (el, { cleanup: cleanup2 }) => (name, key = null) => {\n  let cacheKey = `${name}${key ? `-${key}` : \"\"}`;\n  return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {\n    let root = closestIdRoot(el, name);\n    let id = root ? root._x_ids[name] : findAndIncrementId(name);\n    return key ? `${name}-${id}-${key}` : `${name}-${id}`;\n  });\n});\ninterceptClone((from, to) => {\n  if (from._x_id) {\n    to._x_id = from._x_id;\n  }\n});\nfunction cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {\n  if (!el._x_id)\n    el._x_id = {};\n  if (el._x_id[cacheKey])\n    return el._x_id[cacheKey];\n  let output = callback();\n  el._x_id[cacheKey] = output;\n  cleanup2(() => {\n    delete el._x_id[cacheKey];\n  });\n  return output;\n}\n\n// packages/alpinejs/src/magics/$el.js\nmagic(\"el\", (el) => el);\n\n// packages/alpinejs/src/magics/index.js\nwarnMissingPluginMagic(\"Focus\", \"focus\", \"focus\");\nwarnMissingPluginMagic(\"Persist\", \"persist\", \"persist\");\nfunction warnMissingPluginMagic(name, magicName, slug) {\n  magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/directives/x-modelable.js\ndirective(\"modelable\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {\n  let func = evaluateLater2(expression);\n  let innerGet = () => {\n    let result;\n    func((i) => result = i);\n    return result;\n  };\n  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);\n  let innerSet = (val) => evaluateInnerSet(() => {\n  }, { scope: { \"__placeholder\": val } });\n  let initialValue = innerGet();\n  innerSet(initialValue);\n  queueMicrotask(() => {\n    if (!el._x_model)\n      return;\n    el._x_removeModelListeners[\"default\"]();\n    let outerGet = el._x_model.get;\n    let outerSet = el._x_model.set;\n    let releaseEntanglement = entangle(\n      {\n        get() {\n          return outerGet();\n        },\n        set(value) {\n          outerSet(value);\n        }\n      },\n      {\n        get() {\n          return innerGet();\n        },\n        set(value) {\n          innerSet(value);\n        }\n      }\n    );\n    cleanup2(releaseEntanglement);\n  });\n});\n\n// packages/alpinejs/src/directives/x-teleport.js\ndirective(\"teleport\", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-teleport can only be used on a <template> tag\", el);\n  let target = getTarget(expression);\n  let clone2 = el.content.cloneNode(true).firstElementChild;\n  el._x_teleport = clone2;\n  clone2._x_teleportBack = el;\n  el.setAttribute(\"data-teleport-template\", true);\n  clone2.setAttribute(\"data-teleport-target\", true);\n  if (el._x_forwardEvents) {\n    el._x_forwardEvents.forEach((eventName) => {\n      clone2.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        el.dispatchEvent(new e.constructor(e.type, e));\n      });\n    });\n  }\n  addScopeToNode(clone2, {}, el);\n  let placeInDom = (clone3, target2, modifiers2) => {\n    if (modifiers2.includes(\"prepend\")) {\n      target2.parentNode.insertBefore(clone3, target2);\n    } else if (modifiers2.includes(\"append\")) {\n      target2.parentNode.insertBefore(clone3, target2.nextSibling);\n    } else {\n      target2.appendChild(clone3);\n    }\n  };\n  mutateDom(() => {\n    placeInDom(clone2, target, modifiers);\n    skipDuringClone(() => {\n      initTree(clone2);\n      clone2._x_ignore = true;\n    })();\n  });\n  el._x_teleportPutBack = () => {\n    let target2 = getTarget(expression);\n    mutateDom(() => {\n      placeInDom(el._x_teleport, target2, modifiers);\n    });\n  };\n  cleanup2(() => clone2.remove());\n});\nvar teleportContainerDuringClone = document.createElement(\"div\");\nfunction getTarget(expression) {\n  let target = skipDuringClone(() => {\n    return document.querySelector(expression);\n  }, () => {\n    return teleportContainerDuringClone;\n  })();\n  if (!target)\n    warn(`Cannot find x-teleport element for selector: \"${expression}\"`);\n  return target;\n}\n\n// packages/alpinejs/src/directives/x-ignore.js\nvar handler = () => {\n};\nhandler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup2(() => {\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\ndirective(\"ignore\", handler);\n\n// packages/alpinejs/src/directives/x-effect.js\ndirective(\"effect\", skipDuringClone((el, { expression }, { effect: effect3 }) => {\n  effect3(evaluateLater(el, expression));\n}));\n\n// packages/alpinejs/src/utils/on.js\nfunction on(el, event, modifiers, callback) {\n  let listenerTarget = el;\n  let handler4 = (e) => callback(e);\n  let options = {};\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\n  if (modifiers.includes(\"dot\"))\n    event = dotSyntax(event);\n  if (modifiers.includes(\"camel\"))\n    event = camelCase2(event);\n  if (modifiers.includes(\"passive\"))\n    options.passive = true;\n  if (modifiers.includes(\"capture\"))\n    options.capture = true;\n  if (modifiers.includes(\"window\"))\n    listenerTarget = window;\n  if (modifiers.includes(\"document\"))\n    listenerTarget = document;\n  if (modifiers.includes(\"debounce\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler4 = debounce(handler4, wait);\n  }\n  if (modifiers.includes(\"throttle\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler4 = throttle(handler4, wait);\n  }\n  if (modifiers.includes(\"prevent\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.preventDefault();\n      next(e);\n    });\n  if (modifiers.includes(\"stop\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.stopPropagation();\n      next(e);\n    });\n  if (modifiers.includes(\"once\")) {\n    handler4 = wrapHandler(handler4, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler4, options);\n    });\n  }\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\n    listenerTarget = document;\n    handler4 = wrapHandler(handler4, (next, e) => {\n      if (el.contains(e.target))\n        return;\n      if (e.target.isConnected === false)\n        return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\n        return;\n      if (el._x_isShown === false)\n        return;\n      next(e);\n    });\n  }\n  if (modifiers.includes(\"self\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.target === el && next(e);\n    });\n  if (isKeyEvent(event) || isClickEvent(event)) {\n    handler4 = wrapHandler(handler4, (next, e) => {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n      next(e);\n    });\n  }\n  listenerTarget.addEventListener(event, handler4, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler4, options);\n  };\n}\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, \".\");\n}\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction kebabCase2(subject) {\n  if ([\" \", \"_\"].includes(\n    subject\n  ))\n    return subject;\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n}\nfunction isKeyEvent(event) {\n  return [\"keydown\", \"keyup\"].includes(event);\n}\nfunction isClickEvent(event) {\n  return [\"contextmenu\", \"click\", \"mouse\"].some((i) => event.includes(i));\n}\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  let keyModifiers = modifiers.filter((i) => {\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\", \"capture\", \"self\", \"away\", \"outside\", \"passive\"].includes(i);\n  });\n  if (keyModifiers.includes(\"debounce\")) {\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.includes(\"throttle\")) {\n    let debounceIndex = keyModifiers.indexOf(\"throttle\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.length === 0)\n    return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\n    return false;\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\n  if (selectedSystemKeyModifiers.length > 0) {\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\n      if (modifier === \"cmd\" || modifier === \"super\")\n        modifier = \"meta\";\n      return e[`${modifier}Key`];\n    });\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (isClickEvent(e.type))\n        return false;\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction keyToModifiers(key) {\n  if (!key)\n    return [];\n  key = kebabCase2(key);\n  let modifierToKeyMap = {\n    \"ctrl\": \"control\",\n    \"slash\": \"/\",\n    \"space\": \" \",\n    \"spacebar\": \" \",\n    \"cmd\": \"meta\",\n    \"esc\": \"escape\",\n    \"up\": \"arrow-up\",\n    \"down\": \"arrow-down\",\n    \"left\": \"arrow-left\",\n    \"right\": \"arrow-right\",\n    \"period\": \".\",\n    \"comma\": \",\",\n    \"equal\": \"=\",\n    \"minus\": \"-\",\n    \"underscore\": \"_\"\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map((modifier) => {\n    if (modifierToKeyMap[modifier] === key)\n      return modifier;\n  }).filter((modifier) => modifier);\n}\n\n// packages/alpinejs/src/directives/x-model.js\ndirective(\"model\", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  let scopeTarget = el;\n  if (modifiers.includes(\"parent\")) {\n    scopeTarget = el.parentNode;\n  }\n  let evaluateGet = evaluateLater(scopeTarget, expression);\n  let evaluateSet;\n  if (typeof expression === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);\n  } else if (typeof expression === \"function\" && typeof expression() === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);\n  } else {\n    evaluateSet = () => {\n    };\n  }\n  let getValue = () => {\n    let result;\n    evaluateGet((value) => result = value);\n    return isGetterSetter(result) ? result.get() : result;\n  };\n  let setValue = (value) => {\n    let result;\n    evaluateGet((value2) => result = value2);\n    if (isGetterSetter(result)) {\n      result.set(value);\n    } else {\n      evaluateSet(() => {\n      }, {\n        scope: { \"__placeholder\": value }\n      });\n    }\n  };\n  if (typeof expression === \"string\" && el.type === \"radio\") {\n    mutateDom(() => {\n      if (!el.hasAttribute(\"name\"))\n        el.setAttribute(\"name\", expression);\n    });\n  }\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n  let removeListener = isCloning ? () => {\n  } : on(el, event, modifiers, (e) => {\n    setValue(getInputValue(el, modifiers, e, getValue()));\n  });\n  if (modifiers.includes(\"fill\")) {\n    if ([void 0, null, \"\"].includes(getValue()) || el.type === \"checkbox\" && Array.isArray(getValue()) || el.tagName.toLowerCase() === \"select\" && el.multiple) {\n      setValue(\n        getInputValue(el, modifiers, { target: el }, getValue())\n      );\n    }\n  }\n  if (!el._x_removeModelListeners)\n    el._x_removeModelListeners = {};\n  el._x_removeModelListeners[\"default\"] = removeListener;\n  cleanup2(() => el._x_removeModelListeners[\"default\"]());\n  if (el.form) {\n    let removeResetListener = on(el.form, \"reset\", [], (e) => {\n      nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));\n    });\n    cleanup2(() => removeResetListener());\n  }\n  el._x_model = {\n    get() {\n      return getValue();\n    },\n    set(value) {\n      setValue(value);\n    }\n  };\n  el._x_forceModelUpdate = (value) => {\n    if (value === void 0 && typeof expression === \"string\" && expression.match(/\\./))\n      value = \"\";\n    window.fromModel = true;\n    mutateDom(() => bind(el, \"value\", value));\n    delete window.fromModel;\n  };\n  effect3(() => {\n    let value = getValue();\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\n      return;\n    el._x_forceModelUpdate(value);\n  });\n});\nfunction getInputValue(el, modifiers, event, currentValue) {\n  return mutateDom(() => {\n    if (event instanceof CustomEvent && event.detail !== void 0)\n      return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;\n    else if (el.type === \"checkbox\") {\n      if (Array.isArray(currentValue)) {\n        let newValue = null;\n        if (modifiers.includes(\"number\")) {\n          newValue = safeParseNumber(event.target.value);\n        } else if (modifiers.includes(\"boolean\")) {\n          newValue = safeParseBoolean(event.target.value);\n        } else {\n          newValue = event.target.value;\n        }\n        return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\n      } else {\n        return event.target.checked;\n      }\n    } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\n      if (modifiers.includes(\"number\")) {\n        return Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        });\n      } else if (modifiers.includes(\"boolean\")) {\n        return Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseBoolean(rawValue);\n        });\n      }\n      return Array.from(event.target.selectedOptions).map((option) => {\n        return option.value || option.text;\n      });\n    } else {\n      let newValue;\n      if (el.type === \"radio\") {\n        if (event.target.checked) {\n          newValue = event.target.value;\n        } else {\n          newValue = currentValue;\n        }\n      } else {\n        newValue = event.target.value;\n      }\n      if (modifiers.includes(\"number\")) {\n        return safeParseNumber(newValue);\n      } else if (modifiers.includes(\"boolean\")) {\n        return safeParseBoolean(newValue);\n      } else if (modifiers.includes(\"trim\")) {\n        return newValue.trim();\n      } else {\n        return newValue;\n      }\n    }\n  });\n}\nfunction safeParseNumber(rawValue) {\n  let number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction isGetterSetter(value) {\n  return value !== null && typeof value === \"object\" && typeof value.get === \"function\" && typeof value.set === \"function\";\n}\n\n// packages/alpinejs/src/directives/x-cloak.js\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\n\n// packages/alpinejs/src/directives/x-init.js\naddInitSelector(() => `[${prefix(\"init\")}]`);\ndirective(\"init\", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"string\") {\n    return !!expression.trim() && evaluate2(expression, {}, false);\n  }\n  return evaluate2(expression, {}, false);\n}));\n\n// packages/alpinejs/src/directives/x-text.js\ndirective(\"text\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-html.js\ndirective(\"html\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.innerHTML = value;\n        el._x_ignoreSelf = true;\n        initTree(el);\n        delete el._x_ignoreSelf;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-bind.js\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\nvar handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {\n  if (!value) {\n    let bindingProviders = {};\n    injectBindingProviders(bindingProviders);\n    let getBindings = evaluateLater(el, expression);\n    getBindings((bindings) => {\n      applyBindingsObject(el, bindings, original);\n    }, { scope: bindingProviders });\n    return;\n  }\n  if (value === \"key\")\n    return storeKeyForXFor(el, expression);\n  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {\n    return;\n  }\n  let evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2((result) => {\n    if (result === void 0 && typeof expression === \"string\" && expression.match(/\\./)) {\n      result = \"\";\n    }\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n  cleanup2(() => {\n    el._x_undoAddedClasses && el._x_undoAddedClasses();\n    el._x_undoAddedStyles && el._x_undoAddedStyles();\n  });\n};\nhandler2.inline = (el, { value, modifiers, expression }) => {\n  if (!value)\n    return;\n  if (!el._x_inlineBindings)\n    el._x_inlineBindings = {};\n  el._x_inlineBindings[value] = { expression, extract: false };\n};\ndirective(\"bind\", handler2);\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n}\n\n// packages/alpinejs/src/directives/x-data.js\naddRootSelector(() => `[${prefix(\"data\")}]`);\ndirective(\"data\", (el, { expression }, { cleanup: cleanup2 }) => {\n  if (shouldSkipRegisteringDataDuringClone(el))\n    return;\n  expression = expression === \"\" ? \"{}\" : expression;\n  let magicContext = {};\n  injectMagics(magicContext, el);\n  let dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  let data2 = evaluate(el, expression, { scope: dataProviderContext });\n  if (data2 === void 0 || data2 === true)\n    data2 = {};\n  injectMagics(data2, el);\n  let reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  let undo = addScopeToNode(el, reactiveData);\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\n  cleanup2(() => {\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\n    undo();\n  });\n});\ninterceptClone((from, to) => {\n  if (from._x_dataStack) {\n    to._x_dataStack = from._x_dataStack;\n    to.setAttribute(\"data-has-alpine-state\", true);\n  }\n});\nfunction shouldSkipRegisteringDataDuringClone(el) {\n  if (!isCloning)\n    return false;\n  if (isCloningLegacy)\n    return true;\n  return el.hasAttribute(\"data-has-alpine-state\");\n}\n\n// packages/alpinejs/src/directives/x-show.js\ndirective(\"show\", (el, { modifiers, expression }, { effect: effect3 }) => {\n  let evaluate2 = evaluateLater(el, expression);\n  if (!el._x_doHide)\n    el._x_doHide = () => {\n      mutateDom(() => {\n        el.style.setProperty(\"display\", \"none\", modifiers.includes(\"important\") ? \"important\" : void 0);\n      });\n    };\n  if (!el._x_doShow)\n    el._x_doShow = () => {\n      mutateDom(() => {\n        if (el.style.length === 1 && el.style.display === \"none\") {\n          el.removeAttribute(\"style\");\n        } else {\n          el.style.removeProperty(\"display\");\n        }\n      });\n    };\n  let hide = () => {\n    el._x_doHide();\n    el._x_isShown = false;\n  };\n  let show = () => {\n    el._x_doShow();\n    el._x_isShown = true;\n  };\n  let clickAwayCompatibleShow = () => setTimeout(show);\n  let toggle = once(\n    (value) => value ? show() : hide(),\n    (value) => {\n      if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\n        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n      } else {\n        value ? clickAwayCompatibleShow() : hide();\n      }\n    }\n  );\n  let oldValue;\n  let firstTime = true;\n  effect3(() => evaluate2((value) => {\n    if (!firstTime && value === oldValue)\n      return;\n    if (modifiers.includes(\"immediate\"))\n      value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/directives/x-for.js\ndirective(\"for\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  let iteratorNames = parseForExpression(expression);\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\n  let evaluateKey = evaluateLater(\n    el,\n    // the x-bind:key expression is stored for our use instead of evaluated.\n    el._x_keyExpression || \"index\"\n  );\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup2(() => {\n    Object.values(el._x_lookup).forEach((el2) => el2.remove());\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  let isObject2 = (i) => typeof i === \"object\" && !Array.isArray(i);\n  let templateEl = el;\n  evaluateItems((items) => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), (i) => i + 1);\n    }\n    if (items === void 0)\n      items = [];\n    let lookup = el._x_lookup;\n    let prevKeys = el._x_prevKeys;\n    let scopes = [];\n    let keys = [];\n    if (isObject2(items)) {\n      items = Object.entries(items).map(([key, value]) => {\n        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey((value2) => {\n          if (keys.includes(value2))\n            warn(\"Duplicate key on x-for\", el);\n          keys.push(value2);\n        }, { scope: { index: key, ...scope2 } });\n        scopes.push(scope2);\n      });\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey((value) => {\n          if (keys.includes(value))\n            warn(\"Duplicate key on x-for\", el);\n          keys.push(value);\n        }, { scope: { index: i, ...scope2 } });\n        scopes.push(scope2);\n      }\n    }\n    let adds = [];\n    let moves = [];\n    let removes = [];\n    let sames = [];\n    for (let i = 0; i < prevKeys.length; i++) {\n      let key = prevKeys[i];\n      if (keys.indexOf(key) === -1)\n        removes.push(key);\n    }\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\n    let lastKey = \"template\";\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let prevIndex = prevKeys.indexOf(key);\n      if (prevIndex === -1) {\n        prevKeys.splice(i, 0, key);\n        adds.push([lastKey, i]);\n      } else if (prevIndex !== i) {\n        let keyInSpot = prevKeys.splice(i, 1)[0];\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(i, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(key);\n      }\n      lastKey = key;\n    }\n    for (let i = 0; i < removes.length; i++) {\n      let key = removes[i];\n      if (!!lookup[key]._x_effects) {\n        lookup[key]._x_effects.forEach(dequeueJob);\n      }\n      lookup[key].remove();\n      lookup[key] = null;\n      delete lookup[key];\n    }\n    for (let i = 0; i < moves.length; i++) {\n      let [keyInSpot, keyForSpot] = moves[i];\n      let elInSpot = lookup[keyInSpot];\n      let elForSpot = lookup[keyForSpot];\n      let marker = document.createElement(\"div\");\n      mutateDom(() => {\n        if (!elForSpot)\n          warn(`x-for \":key\" is undefined or invalid`, templateEl, keyForSpot, lookup);\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);\n        marker.before(elInSpot);\n        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);\n        marker.remove();\n      });\n      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);\n    }\n    for (let i = 0; i < adds.length; i++) {\n      let [lastKey2, index] = adds[i];\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\n      if (lastEl._x_currentIfEl)\n        lastEl = lastEl._x_currentIfEl;\n      let scope2 = scopes[index];\n      let key = keys[index];\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      let reactiveScope = reactive(scope2);\n      addScopeToNode(clone2, reactiveScope, templateEl);\n      clone2._x_refreshXForScope = (newScope) => {\n        Object.entries(newScope).forEach(([key2, value]) => {\n          reactiveScope[key2] = value;\n        });\n      };\n      mutateDom(() => {\n        lastEl.after(clone2);\n        skipDuringClone(() => initTree(clone2))();\n      });\n      if (typeof key === \"object\") {\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\n      }\n      lookup[key] = clone2;\n    }\n    for (let i = 0; i < sames.length; i++) {\n      lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);\n    }\n    templateEl._x_prevKeys = keys;\n  });\n}\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  let inMatch = expression.match(forAliasRE);\n  if (!inMatch)\n    return;\n  let res = {};\n  res.items = inMatch[2].trim();\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\n  let iteratorMatch = item.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, \"\").trim();\n    res.index = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n  return res;\n}\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  let scopeVariables = {};\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name) => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n  if (iteratorNames.index)\n    scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection)\n    scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-ref.js\nfunction handler3() {\n}\nhandler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {\n  let root = closestRoot(el);\n  if (!root._x_refs)\n    root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup2(() => delete root._x_refs[expression]);\n};\ndirective(\"ref\", handler3);\n\n// packages/alpinejs/src/directives/x-if.js\ndirective(\"if\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-if can only be used on a <template> tag\", el);\n  let evaluate2 = evaluateLater(el, expression);\n  let show = () => {\n    if (el._x_currentIfEl)\n      return el._x_currentIfEl;\n    let clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      skipDuringClone(() => initTree(clone2))();\n    });\n    el._x_currentIfEl = clone2;\n    el._x_undoIf = () => {\n      walk(clone2, (node) => {\n        if (!!node._x_effects) {\n          node._x_effects.forEach(dequeueJob);\n        }\n      });\n      clone2.remove();\n      delete el._x_currentIfEl;\n    };\n    return clone2;\n  };\n  let hide = () => {\n    if (!el._x_undoIf)\n      return;\n    el._x_undoIf();\n    delete el._x_undoIf;\n  };\n  effect3(() => evaluate2((value) => {\n    value ? show() : hide();\n  }));\n  cleanup2(() => el._x_undoIf && el._x_undoIf());\n});\n\n// packages/alpinejs/src/directives/x-id.js\ndirective(\"id\", (el, { expression }, { evaluate: evaluate2 }) => {\n  let names = evaluate2(expression);\n  names.forEach((name) => setIdRoot(el, name));\n});\ninterceptClone((from, to) => {\n  if (from._x_ids) {\n    to._x_ids = from._x_ids;\n  }\n});\n\n// packages/alpinejs/src/directives/x-on.js\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\ndirective(\"on\", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\n  };\n  if (el.tagName.toLowerCase() === \"template\") {\n    if (!el._x_forwardEvents)\n      el._x_forwardEvents = [];\n    if (!el._x_forwardEvents.includes(value))\n      el._x_forwardEvents.push(value);\n  }\n  let removeListener = on(el, value, modifiers, (e) => {\n    evaluate2(() => {\n    }, { scope: { \"$event\": e }, params: [e] });\n  });\n  cleanup2(() => removeListener());\n}));\n\n// packages/alpinejs/src/directives/index.js\nwarnMissingPluginDirective(\"Collapse\", \"collapse\", \"collapse\");\nwarnMissingPluginDirective(\"Intersect\", \"intersect\", \"intersect\");\nwarnMissingPluginDirective(\"Focus\", \"trap\", \"focus\");\nwarnMissingPluginDirective(\"Mask\", \"mask\", \"mask\");\nfunction warnMissingPluginDirective(name, directiveName, slug) {\n  directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/index.js\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });\nvar src_default = alpine_default;\n\n// packages/alpinejs/builds/module.js\nvar module_default = src_default;\n\n\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/alpinejs/dist/module.esm.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/Client.js":
/*!****************************************************!*\
  !*** ./node_modules/archipelago.js/dist/Client.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _Client_instances, _Client_socket, _Client_status, _Client_emitter, _Client_dataManager, _Client_hintManager, _Client_itemsManager, _Client_locationsManager, _Client_playersManager, _Client_finalizeConnection, _Client_connectSocket, _Client_parsePackets, _Client_consolidateMessage;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MINIMUM_SUPPORTED_AP_VERSION = exports.Client = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst isomorphic_ws_1 = __importDefault(__webpack_require__(/*! isomorphic-ws */ \"./node_modules/isomorphic-ws/browser.js\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/commonjs-browser/index.js\");\nconst CommandPacketType_1 = __webpack_require__(/*! ./consts/CommandPacketType */ \"./node_modules/archipelago.js/dist/consts/CommandPacketType.js\");\nconst ConnectionStatus_1 = __webpack_require__(/*! ./consts/ConnectionStatus */ \"./node_modules/archipelago.js/dist/consts/ConnectionStatus.js\");\nconst PrintJSONType_1 = __webpack_require__(/*! ./consts/PrintJSONType */ \"./node_modules/archipelago.js/dist/consts/PrintJSONType.js\");\nconst DataManager_1 = __webpack_require__(/*! ./managers/DataManager */ \"./node_modules/archipelago.js/dist/managers/DataManager.js\");\nconst HintsManager_1 = __webpack_require__(/*! ./managers/HintsManager */ \"./node_modules/archipelago.js/dist/managers/HintsManager.js\");\nconst ItemsManager_1 = __webpack_require__(/*! ./managers/ItemsManager */ \"./node_modules/archipelago.js/dist/managers/ItemsManager.js\");\nconst LocationsManager_1 = __webpack_require__(/*! ./managers/LocationsManager */ \"./node_modules/archipelago.js/dist/managers/LocationsManager.js\");\nconst PlayersManager_1 = __webpack_require__(/*! ./managers/PlayersManager */ \"./node_modules/archipelago.js/dist/managers/PlayersManager.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/archipelago.js/dist/types/index.js\");\n/**\n * The client that connects to an Archipelago server and facilitates communication, listens for events, and manages\n * data.\n */\nclass Client {\n    constructor() {\n        _Client_instances.add(this);\n        _Client_socket.set(this, void 0);\n        _Client_status.set(this, ConnectionStatus_1.CONNECTION_STATUS.DISCONNECTED);\n        _Client_emitter.set(this, new events_1.EventEmitter());\n        _Client_dataManager.set(this, new DataManager_1.DataManager(this));\n        _Client_hintManager.set(this, new HintsManager_1.HintsManager(this));\n        _Client_itemsManager.set(this, new ItemsManager_1.ItemsManager(this));\n        _Client_locationsManager.set(this, new LocationsManager_1.LocationsManager(this));\n        _Client_playersManager.set(this, new PlayersManager_1.PlayersManager(this));\n    }\n    /**\n     * Get the current WebSocket connection status to the Archipelago server.\n     */\n    get status() {\n        return __classPrivateFieldGet(this, _Client_status, \"f\");\n    }\n    /**\n     * Get the {@link DataManager} helper object. See {@link DataManager} for additional information.\n     */\n    get data() {\n        return __classPrivateFieldGet(this, _Client_dataManager, \"f\");\n    }\n    /**\n     * Get the {@link HintsManager} helper object. See {@link HintsManager} for additional information.\n     */\n    get hints() {\n        return __classPrivateFieldGet(this, _Client_hintManager, \"f\");\n    }\n    /**\n     * Get the {@link ItemsManager} helper object. See {@link ItemsManager} for additional information.\n     */\n    get items() {\n        return __classPrivateFieldGet(this, _Client_itemsManager, \"f\");\n    }\n    /**\n     * Get the {@link LocationsManager} helper object. See {@link LocationsManager} for additional information.\n     */\n    get locations() {\n        return __classPrivateFieldGet(this, _Client_locationsManager, \"f\");\n    }\n    /**\n     * Get the {@link PlayersManager} helper object. See {@link PlayersManager} for additional information.\n     */\n    get players() {\n        return __classPrivateFieldGet(this, _Client_playersManager, \"f\");\n    }\n    /**\n     * Get the URI of the current connection, including protocol.\n     */\n    get uri() {\n        if (__classPrivateFieldGet(this, _Client_socket, \"f\")) {\n            return __classPrivateFieldGet(this, _Client_socket, \"f\").url;\n        }\n        return;\n    }\n    /**\n     * Connects to the given address with given connection information.\n     *\n     * @param info All the necessary connection information to connect to an Archipelago server.\n     *\n     * @resolves On successful connection and authentication to the room.\n     * @rejects If web socket connection failed to establish connection or server refused connection, promise will\n     * return a `string[]` of error messages.\n     */\n    connect(info) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Confirm a valid port was given.\n            if (info.port < 1 || info.port > 65535 || !Number.isInteger(info.port))\n                throw new Error(`Port must be an integer between 1 and 65535. Received: ${info.port}`);\n            try {\n                // First establish the initial connection.\n                __classPrivateFieldSet(this, _Client_status, ConnectionStatus_1.CONNECTION_STATUS.CONNECTING, \"f\");\n                if (info.protocol === \"ws\") {\n                    yield __classPrivateFieldGet(this, _Client_instances, \"m\", _Client_connectSocket).call(this, `ws://${info.hostname}:${info.port}/`);\n                }\n                else if (info.protocol === \"wss\") {\n                    yield __classPrivateFieldGet(this, _Client_instances, \"m\", _Client_connectSocket).call(this, `wss://${info.hostname}:${info.port}/`);\n                }\n                else {\n                    try {\n                        // Attempt a secure connection first.\n                        yield __classPrivateFieldGet(this, _Client_instances, \"m\", _Client_connectSocket).call(this, `wss://${info.hostname}:${info.port}/`);\n                    }\n                    catch (_a) {\n                        // Failing that, attempt to connect to normal websocket.\n                        yield __classPrivateFieldGet(this, _Client_instances, \"m\", _Client_connectSocket).call(this, `ws://${info.hostname}:${info.port}/`);\n                    }\n                }\n                // Wait for data package to complete, then finalize connection.\n                return yield new Promise((resolve, reject) => {\n                    const onDataPackageLoaded = () => {\n                        __classPrivateFieldGet(this, _Client_instances, \"m\", _Client_finalizeConnection).call(this, info)\n                            .then((connectPacket) => {\n                            __classPrivateFieldGet(this, _Client_emitter, \"f\").removeListener(\"__onRoomInfoLoaded\", onDataPackageLoaded.bind(this));\n                            resolve(connectPacket);\n                        })\n                            .catch((error) => reject(error));\n                    };\n                    __classPrivateFieldGet(this, _Client_emitter, \"f\").addListener(\"__onRoomInfoLoaded\", onDataPackageLoaded.bind(this));\n                });\n            }\n            catch (error) {\n                this.disconnect();\n                throw error;\n            }\n        });\n    }\n    /**\n     * Not meant for users of archipelago.js to use, just an easy way for me to pass events around.\n     *\n     * @internal\n     */\n    emitRawEvent(event, ...args) {\n        __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(event, ...args);\n    }\n    /**\n     * Send a list of raw packets to the Archipelago server in the order they are listed as arguments.\n     *\n     * @param packets An array of raw {@link ClientPacket}s to send to the AP server. They are processed in\n     * the order they are listed as arguments.\n     */\n    send(...packets) {\n        var _a;\n        (_a = __classPrivateFieldGet(this, _Client_socket, \"f\")) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(packets));\n    }\n    /**\n     * Send a normal chat message to the server.\n     * @param message The message to send.\n     */\n    say(message) {\n        this.send({ cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.SAY, text: message });\n    }\n    /**\n     * Update the status for this client.\n     * @param status The status code to send.\n     */\n    updateStatus(status) {\n        this.send({ cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.STATUS_UPDATE, status });\n    }\n    /**\n     * Disconnect from the server and re-initialize all managers.\n     */\n    disconnect() {\n        var _a;\n        (_a = __classPrivateFieldGet(this, _Client_socket, \"f\")) === null || _a === void 0 ? void 0 : _a.close();\n        __classPrivateFieldSet(this, _Client_socket, undefined, \"f\");\n        __classPrivateFieldSet(this, _Client_status, ConnectionStatus_1.CONNECTION_STATUS.DISCONNECTED, \"f\");\n        __classPrivateFieldGet(this, _Client_emitter, \"f\").removeAllListeners();\n        // Reinitialize our Managers.\n        __classPrivateFieldSet(this, _Client_dataManager, new DataManager_1.DataManager(this), \"f\");\n        __classPrivateFieldSet(this, _Client_hintManager, new HintsManager_1.HintsManager(this), \"f\");\n        __classPrivateFieldSet(this, _Client_itemsManager, new ItemsManager_1.ItemsManager(this), \"f\");\n        __classPrivateFieldSet(this, _Client_locationsManager, new LocationsManager_1.LocationsManager(this), \"f\");\n        __classPrivateFieldSet(this, _Client_playersManager, new PlayersManager_1.PlayersManager(this), \"f\");\n    }\n    /**\n     * Add an eventListener to fire depending on an event from the Archipelago server or the client.\n     *\n     * @param event The event to listen for.\n     * @param listener The listener callback function to run when an event is fired.\n     */\n    addListener(event, listener) {\n        __classPrivateFieldGet(this, _Client_emitter, \"f\").addListener(event, listener);\n    }\n    /**\n     * Remove an eventListener from this client's event emitter.\n     *\n     * @param event The event to stop listening for.\n     * @param listener The listener callback function to remove.\n     */\n    removeListener(event, listener) {\n        __classPrivateFieldGet(this, _Client_emitter, \"f\").removeListener(event, listener);\n    }\n}\nexports.Client = Client;\n_Client_socket = new WeakMap(), _Client_status = new WeakMap(), _Client_emitter = new WeakMap(), _Client_dataManager = new WeakMap(), _Client_hintManager = new WeakMap(), _Client_itemsManager = new WeakMap(), _Client_locationsManager = new WeakMap(), _Client_playersManager = new WeakMap(), _Client_instances = new WeakSet(), _Client_finalizeConnection = function _Client_finalizeConnection(info) {\n    var _a;\n    const version = (_a = info.version) !== null && _a !== void 0 ? _a : exports.MINIMUM_SUPPORTED_AP_VERSION;\n    return new Promise((resolve, reject) => {\n        var _a, _b, _c;\n        // Successfully connected!\n        const onConnectedListener = (packet) => {\n            __classPrivateFieldSet(this, _Client_status, ConnectionStatus_1.CONNECTION_STATUS.CONNECTED, \"f\");\n            this.removeListener(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTED, onConnectedListener.bind(this));\n            resolve(packet);\n        };\n        const onConnectionRefusedListener = (packet) => {\n            this.disconnect();\n            reject(packet.errors);\n        };\n        this.addListener(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTED, onConnectedListener.bind(this));\n        this.addListener(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTION_REFUSED, onConnectionRefusedListener.bind(this));\n        // Get the data package and connect to room.\n        this.send({\n            cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.GET_DATA_PACKAGE,\n            games: __classPrivateFieldGet(this, _Client_dataManager, \"f\").games,\n        }, {\n            cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.CONNECT,\n            game: info.game,\n            name: info.name,\n            version: Object.assign(Object.assign({}, version), { class: \"Version\" }),\n            items_handling: info.items_handling,\n            uuid: (_a = info.uuid) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)(),\n            tags: (_b = info.tags) !== null && _b !== void 0 ? _b : [],\n            password: (_c = info.password) !== null && _c !== void 0 ? _c : \"\",\n        });\n    });\n}, _Client_connectSocket = function _Client_connectSocket(uri) {\n    return new Promise((resolve, reject) => {\n        __classPrivateFieldSet(this, _Client_socket, new isomorphic_ws_1.default(uri), \"f\");\n        // On successful connection.\n        __classPrivateFieldGet(this, _Client_socket, \"f\").onopen = () => {\n            __classPrivateFieldSet(this, _Client_status, ConnectionStatus_1.CONNECTION_STATUS.WAITING_FOR_AUTH, \"f\");\n            if (__classPrivateFieldGet(this, _Client_socket, \"f\")) {\n                __classPrivateFieldGet(this, _Client_socket, \"f\").onmessage = __classPrivateFieldGet(this, _Client_instances, \"m\", _Client_parsePackets).bind(this);\n                resolve();\n            }\n            else {\n                reject([\"Socket was closed unexpectedly.\"]);\n            }\n        };\n        // On unsuccessful connection.\n        __classPrivateFieldGet(this, _Client_socket, \"f\").onerror = (event) => {\n            __classPrivateFieldSet(this, _Client_status, ConnectionStatus_1.CONNECTION_STATUS.DISCONNECTED, \"f\");\n            reject([event]);\n        };\n    });\n}, _Client_parsePackets = function _Client_parsePackets(event) {\n    // Parse packets and fire our PacketReceived event for each packet.\n    const packets = JSON.parse(event.data.toString());\n    for (const packet of packets) {\n        // Regardless of what type of event this is, we always emit the PacketReceived event.\n        __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(\"PacketReceived\", packet);\n        switch (packet.cmd) {\n            case CommandPacketType_1.SERVER_PACKET_TYPE.INVALID_PACKET:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.INVALID_PACKET, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.BOUNCED:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.BOUNCED, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTION_REFUSED:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTION_REFUSED, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTED:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTED, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.DATA_PACKAGE:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.DATA_PACKAGE, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.LOCATION_INFO:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.LOCATION_INFO, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.RECEIVED_ITEMS:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.RECEIVED_ITEMS, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.RETRIEVED:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.RETRIEVED, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.ROOM_INFO:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.ROOM_INFO, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.ROOM_UPDATE:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.ROOM_UPDATE, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.SET_REPLY:\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.SET_REPLY, packet);\n                break;\n            case CommandPacketType_1.SERVER_PACKET_TYPE.PRINT_JSON: {\n                // Add the plain text version of entire message for easy access.\n                __classPrivateFieldGet(this, _Client_emitter, \"f\").emit(CommandPacketType_1.SERVER_PACKET_TYPE.PRINT_JSON, packet, __classPrivateFieldGet(this, _Client_instances, \"m\", _Client_consolidateMessage).call(this, packet));\n                break;\n            }\n        }\n    }\n}, _Client_consolidateMessage = function _Client_consolidateMessage(packet) {\n    // If we're lucky, we can take a shortcut.\n    if (packet.type === PrintJSONType_1.PRINT_JSON_TYPE.CHAT || packet.type === PrintJSONType_1.PRINT_JSON_TYPE.SERVER_CHAT) {\n        return packet.message;\n    }\n    // I guess not, let's reduce through and create message, replacing text as needed if we run into any ids.\n    return packet.data.reduce((string, piece) => {\n        var _a, _b;\n        switch (piece.type) {\n            case types_1.VALID_JSON_MESSAGE_TYPE.PLAYER_ID:\n                return string + this.players.alias(parseInt(piece.text));\n            case types_1.VALID_JSON_MESSAGE_TYPE.LOCATION_ID:\n                return string + ((_a = this.players.get(piece.player)) === null || _a === void 0 ? void 0 : _a.location(parseInt(piece.text)));\n            case types_1.VALID_JSON_MESSAGE_TYPE.ITEM_ID:\n                return string + ((_b = this.players.get(piece.player)) === null || _b === void 0 ? void 0 : _b.item(parseInt(piece.text)));\n            default:\n                return string + piece.text;\n        }\n    }, \"\");\n};\n/** Minimum supported version of Archipelago this library supports. */\nexports.MINIMUM_SUPPORTED_AP_VERSION = {\n    major: 0,\n    minor: 4,\n    build: 2,\n};\n//# sourceMappingURL=Client.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/Client.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/builders/SetOperationsBuilder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/builders/SetOperationsBuilder.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _SetOperationsBuilder_operations, _SetOperationsBuilder_key, _SetOperationsBuilder_default, _SetOperationsBuilder_wantReply;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SetOperationsBuilder = void 0;\nconst CommandPacketType_1 = __webpack_require__(/*! ../consts/CommandPacketType */ \"./node_modules/archipelago.js/dist/consts/CommandPacketType.js\");\n/**\n * A helper class of data operations to perform server-side on a given key.\n */\nclass SetOperationsBuilder {\n    constructor(key, defaultValue, wantReply = false) {\n        _SetOperationsBuilder_operations.set(this, []);\n        _SetOperationsBuilder_key.set(this, void 0);\n        _SetOperationsBuilder_default.set(this, void 0);\n        _SetOperationsBuilder_wantReply.set(this, void 0);\n        __classPrivateFieldSet(this, _SetOperationsBuilder_key, key, \"f\");\n        __classPrivateFieldSet(this, _SetOperationsBuilder_default, defaultValue, \"f\");\n        __classPrivateFieldSet(this, _SetOperationsBuilder_wantReply, wantReply, \"f\");\n    }\n    replace(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"replace\",\n            value,\n        });\n        return this;\n    }\n    default(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"default\",\n            value,\n        });\n        return this;\n    }\n    add(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"add\",\n            value,\n        });\n        return this;\n    }\n    multiply(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"mul\",\n            value,\n        });\n        return this;\n    }\n    power(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"pow\",\n            value,\n        });\n        return this;\n    }\n    modulo(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"mod\",\n            value,\n        });\n        return this;\n    }\n    max(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"max\",\n            value,\n        });\n        return this;\n    }\n    min(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"min\",\n            value,\n        });\n        return this;\n    }\n    and(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"and\",\n            value,\n        });\n        return this;\n    }\n    or(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"or\",\n            value,\n        });\n        return this;\n    }\n    xor(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"xor\",\n            value,\n        });\n        return this;\n    }\n    shiftLeft(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"left_shift\",\n            value,\n        });\n        return this;\n    }\n    shiftRight(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"right_shift\",\n            value,\n        });\n        return this;\n    }\n    remove(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"remove\",\n            value,\n        });\n        return this;\n    }\n    pop(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"pop\",\n            value,\n        });\n        return this;\n    }\n    update(value) {\n        __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\").push({\n            operation: \"update\",\n            value,\n        });\n        return this;\n    }\n    build() {\n        return {\n            cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.SET,\n            key: __classPrivateFieldGet(this, _SetOperationsBuilder_key, \"f\"),\n            default: __classPrivateFieldGet(this, _SetOperationsBuilder_default, \"f\"),\n            want_reply: __classPrivateFieldGet(this, _SetOperationsBuilder_wantReply, \"f\"),\n            operations: __classPrivateFieldGet(this, _SetOperationsBuilder_operations, \"f\"),\n        };\n    }\n}\nexports.SetOperationsBuilder = SetOperationsBuilder;\n_SetOperationsBuilder_operations = new WeakMap(), _SetOperationsBuilder_key = new WeakMap(), _SetOperationsBuilder_default = new WeakMap(), _SetOperationsBuilder_wantReply = new WeakMap();\n//# sourceMappingURL=SetOperationsBuilder.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/builders/SetOperationsBuilder.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/ClientStatus.js":
/*!*****************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/ClientStatus.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CLIENT_STATUS = void 0;\n/**\n *  An enumeration containing the possible client states that may be used to inform the server in\n * {@link StatusUpdatePacket}.\n */\nexports.CLIENT_STATUS = {\n    /** Client is in an unknown state. */\n    UNKNOWN: 0,\n    /** Client is currently connected. */\n    CONNECTED: 5,\n    /** Client is current ready to start. */\n    READY: 10,\n    /** Client is currently playing. */\n    PLAYING: 20,\n    /** Client has completed their goal. */\n    GOAL: 30,\n};\n//# sourceMappingURL=ClientStatus.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/ClientStatus.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/CommandPacketType.js":
/*!**********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/CommandPacketType.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CLIENT_PACKET_TYPE = exports.SERVER_PACKET_TYPE = void 0;\n/**\n * A const of all possible packet types the server can send to the client. See each packet's documentation page for\n * additional information on each packet type.\n */\nexports.SERVER_PACKET_TYPE = {\n    BOUNCED: \"Bounced\",\n    CONNECTED: \"Connected\",\n    CONNECTION_REFUSED: \"ConnectionRefused\",\n    DATA_PACKAGE: \"DataPackage\",\n    INVALID_PACKET: \"InvalidPacket\",\n    LOCATION_INFO: \"LocationInfo\",\n    PRINT_JSON: \"PrintJSON\",\n    RECEIVED_ITEMS: \"ReceivedItems\",\n    RETRIEVED: \"Retrieved\",\n    ROOM_INFO: \"RoomInfo\",\n    ROOM_UPDATE: \"RoomUpdate\",\n    SET_REPLY: \"SetReply\",\n};\n/**\n * A const of all possible packet types the client can send to the server. See each packet's documentation page for\n * additional information on each packet type.\n */\nexports.CLIENT_PACKET_TYPE = {\n    BOUNCE: \"Bounce\",\n    CONNECT: \"Connect\",\n    CONNECT_UPDATE: \"ConnectUpdate\",\n    GET_DATA_PACKAGE: \"GetDataPackage\",\n    GET: \"Get\",\n    LOCATION_CHECKS: \"LocationChecks\",\n    LOCATION_SCOUTS: \"LocationScouts\",\n    SAY: \"Say\",\n    SET_NOTIFY: \"SetNotify\",\n    SET: \"Set\",\n    STATUS_UPDATE: \"StatusUpdate\",\n    SYNC: \"Sync\",\n};\n//# sourceMappingURL=CommandPacketType.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/CommandPacketType.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/CommonTags.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/CommonTags.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.COMMON_TAGS = void 0;\n/**\n * Tags are represented as a list of strings, these are some of the most common tags.\n */\nexports.COMMON_TAGS = {\n    /**\n     * Signifies that this client is a reference client, its usefulness is mostly in debugging to compare client\n     * behaviours more easily.\n     *\n     * **This tag should only be utilized by clients that come pre-packaged with Archipelago.**\n     */\n    REFERENCE_CLIENT: \"AP\",\n    /**\n     * Client participates in the DeathLink mechanic, therefore will send and receive DeathLink {@link BouncePacket}s.\n     */\n    DEATH_LINK: \"DeathLink\",\n    /**\n     * Tells the server that this client will not send locations and is actually a Tracker. When specified and used with\n     * an empty `game` in the {@link ConnectPacket}, `game` and `game`'s version validation will be skipped.\n     */\n    TRACKER: \"Tracker\",\n    /**\n     * Tells the server that this client will not send locations and is intended for chat. When specified and used with\n     * an empty `game` in the {@link ConnectPacket}, `game` and `game`'s version validation will be skipped.\n     */\n    TEXT_ONLY: \"TextOnly\",\n};\n//# sourceMappingURL=CommonTags.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/CommonTags.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/ConnectionError.js":
/*!********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/ConnectionError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CONNECTION_ERROR = void 0;\n/**\n * An enumeration of known errors the Archipelago server can send back to the client when they receive a\n * {@link ConnectionRefusedPacket}.\n */\nexports.CONNECTION_ERROR = {\n    /** Indicates that the `name` field did not match any auth entry on the server. */\n    INVALID_SLOT: \"InvalidSlot\",\n    /** Indicates that a correctly named slot was found, but the game for it mismatched. */\n    INVALID_GAME: \"InvalidGame\",\n    /** Indicates a version mismatch or an unsupported client version number. */\n    INCOMPATIBLE_VERSION: \"IncompatibleVersion\",\n    /** Indicates the wrong, or no password when it was required, was sent. */\n    INVALID_PASSWORD: \"InvalidPassword\",\n    /** Indicates a wrong value type or flag combination was sent. */\n    INVALID_ITEMS_HANDLING: \"InvalidItemsHandling\",\n};\n//# sourceMappingURL=ConnectionError.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/ConnectionError.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/ConnectionStatus.js":
/*!*********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/ConnectionStatus.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CONNECTION_STATUS = void 0;\n/**\n * A const of the current {@link Client} connection status to the Archipelago server.\n */\nexports.CONNECTION_STATUS = {\n    /** Currently not connected to any Archipelago server. */\n    DISCONNECTED: \"Disconnected\",\n    /** Attempting to establish a connection to the Archipelago server. */\n    CONNECTING: \"Connecting\",\n    /** Connected to the Archipelago server, but awaiting to authenticate to join the room. */\n    WAITING_FOR_AUTH: \"Waiting For Authentication\",\n    /** Connected to the Archipelago server and authenticated to the current room. */\n    CONNECTED: \"Connected\",\n};\n//# sourceMappingURL=ConnectionStatus.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/ConnectionStatus.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/CreateAsHintMode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/CreateAsHintMode.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CREATE_AS_HINT_MODE = void 0;\n/**\n * The hint type for `create_as_hint` in {@link LocationScoutsPacket}.\n */\nexports.CREATE_AS_HINT_MODE = {\n    /** Does not mark any location to be hinted and broadcast to clients. */\n    NO_HINT: 0,\n    /** Mark all locations as hinted and show to all relevant clients. */\n    HINT_EVERYTHING: 1,\n    /** Mark all locations as hinted and show only newly hinted locations to relevant clients. */\n    HINT_ONLY_NEW: 2,\n};\n//# sourceMappingURL=CreateAsHintMode.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/CreateAsHintMode.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/ItemFlags.js":
/*!**************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/ItemFlags.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ITEM_FLAGS = void 0;\n/**\n * Bit flags that determine if an item is progression, \"nice to have\", filler, or a trap.\n */\nexports.ITEM_FLAGS = {\n    /** Nothing special about this item. */\n    FILLER: 0,\n    /** If set, indicates the item can unlock logical advancement. */\n    PROGRESSION: 0b001,\n    /** If set, indicates the item is important but not in a way that unlocks advancement. */\n    NEVER_EXCLUDE: 0b010,\n    /** If set, indicates the item is a trap that can inconvenience the player. */\n    TRAP: 0b100,\n};\n//# sourceMappingURL=ItemFlags.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/ItemFlags.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/ItemsHandlingFlags.js":
/*!***********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/ItemsHandlingFlags.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ITEMS_HANDLING_FLAGS = void 0;\n/**\n * Bit flags configuring which items should be sent by the server to this client.\n */\nexports.ITEMS_HANDLING_FLAGS = {\n    /** No ReceivedItems is sent to you, ever. */\n    LOCAL_ONLY: 0b000,\n    /** Indicates you get items sent from other worlds. */\n    REMOTE_DIFFERENT_WORLDS: 0b001,\n    /** Indicates you get items sent from your own world. Requires `REMOTE_DIFFERENT_WORLDS` to be set. */\n    REMOTE_OWN_WORLD: 0b010,\n    /** Indicates you get your starting inventory sent. Requires `REMOTE_DIFFERENT_WORLDS` to be set. */\n    REMOTE_STARTING_INVENTORY: 0b100,\n    /** Shorthand for `REMOTE_DIFFERENT_WORLDS`, `REMOTE_OWN_WORLD`, and `REMOTE_STARTING_INVENTORY`. */\n    REMOTE_ALL: 0b111,\n};\n//# sourceMappingURL=ItemsHandlingFlags.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/ItemsHandlingFlags.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/PacketProblemType.js":
/*!**********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/PacketProblemType.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKET_PROBLEM_TYPE = void 0;\n/**\n * PacketProblemType indicates the type of problem that was detected in the faulty packet, the known problem types are\n * below but others may be added in the future.\n */\nexports.PACKET_PROBLEM_TYPE = {\n    /** `cmd` argument of the faulty packet that could not be parsed correctly. */\n    CMD: \"cmd\",\n    /** Arguments of the faulty packet which were not correct. */\n    ARGUMENTS: \"arguments\",\n};\n//# sourceMappingURL=PacketProblemType.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/PacketProblemType.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/Permission.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/Permission.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.REDUCED_PERMISSION = exports.PERMISSION = void 0;\n/**\n * A const containing the possible command permissions, for commands that may be restricted.\n */\nexports.PERMISSION = {\n    /** Prevents players from using this command at any time. */\n    DISABLED: 0,\n    /** Allows players to use this command manually at any time. */\n    ENABLED: 0b001,\n    /** Allows players to use this command manually after they have completed their goal. */\n    GOAL: 0b010,\n    /**\n     * Forces players to use this command after they have completed their goal. Only works for `!release` and `!collect`\n     */\n    AUTO: 0b110,\n    /**\n     * Allows players to use this command manually at any time and forces them to use this command after they have\n     * completed their goal.\n     */\n    AUTO_ENABLED: 0b111,\n};\n/**\n * A const containing the possible command permissions, for commands that may be restricted and do not support auto\n * modes.\n */\nexports.REDUCED_PERMISSION = {\n    /** Prevents players from using this command at any time. */\n    DISABLED: 0,\n    /** Allows players to use this command manually at any time. */\n    ENABLED: 0b001,\n    /** Allows players to use this command manually after they have completed their goal. */\n    GOAL: 0b010,\n};\n//# sourceMappingURL=Permission.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/Permission.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/PrintJSONType.js":
/*!******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/PrintJSONType.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PRINT_JSON_TYPE = void 0;\n/**\n * A const of known {@link PrintJSONPacket} types.\n */\nexports.PRINT_JSON_TYPE = {\n    /** A player received an item. */\n    ITEM_SEND: \"ItemSend\",\n    /** A player used the `!getitem` command. */\n    ITEM_CHEAT: \"ItemCheat\",\n    /** A player hinted. */\n    HINT: \"Hint\",\n    /** A player connected. */\n    JOIN: \"Join\",\n    /** A player disconnected. */\n    PART: \"Part\",\n    /** A player sent a chat message. */\n    CHAT: \"Chat\",\n    /** The server broadcast a message. */\n    SERVER_CHAT: \"ServerChat\",\n    /** The client has triggered a tutorial message, such as when first connecting. */\n    TUTORIAL: \"Tutorial\",\n    /** A player changed their tags. */\n    TAGS_CHANGED: \"TagsChanged\",\n    /** Someone (usually the client) entered an `!` command. */\n    COMMAND_RESULT: \"CommandResult\",\n    /** The client entered an `!admin` command. */\n    ADMIN_COMMAND_RESULT: \"AdminCommandResult\",\n    /** A player reached their goal. */\n    GOAL: \"Goal\",\n    /** A player released the remaining items in their world. */\n    RELEASE: \"Release\",\n    /** A player collected the remaining items for their world. */\n    COLLECT: \"Collect\",\n    /** The current server countdown has progressed. */\n    COUNTDOWN: \"Countdown\",\n};\n//# sourceMappingURL=PrintJSONType.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/PrintJSONType.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/consts/SlotType.js":
/*!*************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/consts/SlotType.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SLOT_TYPE = void 0;\n/**\n * A const representing the nature of the slot.\n */\nexports.SLOT_TYPE = {\n    /** This client is a spectator and not participating in the current game. */\n    SPECTATOR: 0b00,\n    /** This client is a player and is participating in the current game. */\n    PLAYER: 0b01,\n    /** This client is an item links group containing at least 1 player with active item links. */\n    GROUP: 0b10,\n};\n//# sourceMappingURL=SlotType.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/consts/SlotType.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/archipelago.js/dist/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./Client */ \"./node_modules/archipelago.js/dist/Client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./builders/SetOperationsBuilder */ \"./node_modules/archipelago.js/dist/builders/SetOperationsBuilder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/ClientStatus */ \"./node_modules/archipelago.js/dist/consts/ClientStatus.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/CommandPacketType */ \"./node_modules/archipelago.js/dist/consts/CommandPacketType.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/CommonTags */ \"./node_modules/archipelago.js/dist/consts/CommonTags.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/ConnectionError */ \"./node_modules/archipelago.js/dist/consts/ConnectionError.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/ConnectionStatus */ \"./node_modules/archipelago.js/dist/consts/ConnectionStatus.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/CreateAsHintMode */ \"./node_modules/archipelago.js/dist/consts/CreateAsHintMode.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/ItemFlags */ \"./node_modules/archipelago.js/dist/consts/ItemFlags.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/ItemsHandlingFlags */ \"./node_modules/archipelago.js/dist/consts/ItemsHandlingFlags.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/PacketProblemType */ \"./node_modules/archipelago.js/dist/consts/PacketProblemType.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/Permission */ \"./node_modules/archipelago.js/dist/consts/Permission.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/PrintJSONType */ \"./node_modules/archipelago.js/dist/consts/PrintJSONType.js\"), exports);\n__exportStar(__webpack_require__(/*! ./consts/SlotType */ \"./node_modules/archipelago.js/dist/consts/SlotType.js\"), exports);\n__exportStar(__webpack_require__(/*! ./managers/DataManager */ \"./node_modules/archipelago.js/dist/managers/DataManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./managers/HintsManager */ \"./node_modules/archipelago.js/dist/managers/HintsManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./managers/ItemsManager */ \"./node_modules/archipelago.js/dist/managers/ItemsManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./managers/LocationsManager */ \"./node_modules/archipelago.js/dist/managers/LocationsManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./managers/PlayersManager */ \"./node_modules/archipelago.js/dist/managers/PlayersManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/BasePackets */ \"./node_modules/archipelago.js/dist/packets/BasePackets.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/BouncePacket */ \"./node_modules/archipelago.js/dist/packets/BouncePacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/BouncedPacket */ \"./node_modules/archipelago.js/dist/packets/BouncedPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/ConnectPacket */ \"./node_modules/archipelago.js/dist/packets/ConnectPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/ConnectUpdatePacket */ \"./node_modules/archipelago.js/dist/packets/ConnectUpdatePacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/ConnectedPacket */ \"./node_modules/archipelago.js/dist/packets/ConnectedPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/ConnectionRefusedPacket */ \"./node_modules/archipelago.js/dist/packets/ConnectionRefusedPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/DataPackagePacket */ \"./node_modules/archipelago.js/dist/packets/DataPackagePacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/GetDataPackagePacket */ \"./node_modules/archipelago.js/dist/packets/GetDataPackagePacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/GetPacket */ \"./node_modules/archipelago.js/dist/packets/GetPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/InvalidPacketPacket */ \"./node_modules/archipelago.js/dist/packets/InvalidPacketPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/LocationChecksPacket */ \"./node_modules/archipelago.js/dist/packets/LocationChecksPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/LocationInfoPacket */ \"./node_modules/archipelago.js/dist/packets/LocationInfoPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/LocationScoutsPacket */ \"./node_modules/archipelago.js/dist/packets/LocationScoutsPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/PrintJSONPacket */ \"./node_modules/archipelago.js/dist/packets/PrintJSONPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/ReceivedItemsPacket */ \"./node_modules/archipelago.js/dist/packets/ReceivedItemsPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/RetrievedPacket */ \"./node_modules/archipelago.js/dist/packets/RetrievedPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/RoomInfoPacket */ \"./node_modules/archipelago.js/dist/packets/RoomInfoPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/RoomUpdatePacket */ \"./node_modules/archipelago.js/dist/packets/RoomUpdatePacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/SayPacket */ \"./node_modules/archipelago.js/dist/packets/SayPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/SetNotifyPacket */ \"./node_modules/archipelago.js/dist/packets/SetNotifyPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/SetPacket */ \"./node_modules/archipelago.js/dist/packets/SetPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/SetReplyPacket */ \"./node_modules/archipelago.js/dist/packets/SetReplyPacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/StatusUpdatePacket */ \"./node_modules/archipelago.js/dist/packets/StatusUpdatePacket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./packets/SyncPacket */ \"./node_modules/archipelago.js/dist/packets/SyncPacket.js\"), exports);\n// Export types.\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/archipelago.js/dist/types/index.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/index.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/managers/DataManager.js":
/*!******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/managers/DataManager.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _DataManager_instances, _DataManager_client, _DataManager_dataPackage, _DataManager_players, _DataManager_games, _DataManager_hintCost, _DataManager_hintPoints, _DataManager_slotData, _DataManager_slot, _DataManager_team, _DataManager_seed, _DataManager_awaitingSetReplies, _DataManager_permissions, _DataManager_onSetReply, _DataManager_onDataPackage, _DataManager_onConnected, _DataManager_onRoomInfo, _DataManager_onRoomUpdate;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataManager = void 0;\nconst CommandPacketType_1 = __webpack_require__(/*! ../consts/CommandPacketType */ \"./node_modules/archipelago.js/dist/consts/CommandPacketType.js\");\nconst Permission_1 = __webpack_require__(/*! ../consts/Permission */ \"./node_modules/archipelago.js/dist/consts/Permission.js\");\nconst SlotType_1 = __webpack_require__(/*! ../consts/SlotType */ \"./node_modules/archipelago.js/dist/consts/SlotType.js\");\n/**\n * Manages and watches for events regarding session data and the data package. Most other mangers use this information\n * to create helper functions and track other information.\n */\nclass DataManager {\n    /**\n     * Creates a new {@link DataManager} and sets up events on the {@link Client} to listen for to start\n     * updating its internal state.\n     * @param client The {@link Client} that should be managing this manager.\n     */\n    constructor(client) {\n        _DataManager_instances.add(this);\n        _DataManager_client.set(this, void 0);\n        _DataManager_dataPackage.set(this, new Map());\n        _DataManager_players.set(this, []);\n        _DataManager_games.set(this, []);\n        _DataManager_hintCost.set(this, 0);\n        _DataManager_hintPoints.set(this, 0);\n        _DataManager_slotData.set(this, {});\n        _DataManager_slot.set(this, -1);\n        _DataManager_team.set(this, -1);\n        _DataManager_seed.set(this, \"\");\n        _DataManager_awaitingSetReplies.set(this, []);\n        _DataManager_permissions.set(this, {\n            release: Permission_1.PERMISSION.DISABLED,\n            collect: Permission_1.PERMISSION.DISABLED,\n            remaining: Permission_1.PERMISSION.DISABLED,\n        });\n        __classPrivateFieldSet(this, _DataManager_client, client, \"f\");\n        __classPrivateFieldGet(this, _DataManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.DATA_PACKAGE, __classPrivateFieldGet(this, _DataManager_instances, \"m\", _DataManager_onDataPackage).bind(this));\n        __classPrivateFieldGet(this, _DataManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTED, __classPrivateFieldGet(this, _DataManager_instances, \"m\", _DataManager_onConnected).bind(this));\n        __classPrivateFieldGet(this, _DataManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.ROOM_INFO, __classPrivateFieldGet(this, _DataManager_instances, \"m\", _DataManager_onRoomInfo).bind(this));\n        __classPrivateFieldGet(this, _DataManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.ROOM_UPDATE, __classPrivateFieldGet(this, _DataManager_instances, \"m\", _DataManager_onRoomUpdate).bind(this));\n        __classPrivateFieldGet(this, _DataManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.SET_REPLY, __classPrivateFieldGet(this, _DataManager_instances, \"m\", _DataManager_onSetReply).bind(this));\n    }\n    /**\n     * Returns a map of all {@link GamePackage} mapped to their game `name`.\n     */\n    get package() {\n        return __classPrivateFieldGet(this, _DataManager_dataPackage, \"f\");\n    }\n    /**\n     * Returns an array of all `players`, keyed by player id.\n     */\n    get players() {\n        return __classPrivateFieldGet(this, _DataManager_players, \"f\");\n    }\n    /**\n     * Returns an array of all games that exist in this room.\n     */\n    get games() {\n        return __classPrivateFieldGet(this, _DataManager_games, \"f\");\n    }\n    /**\n     * Returns how many hint points a player needs to spend to receive a hint.\n     */\n    get hintCost() {\n        return __classPrivateFieldGet(this, _DataManager_hintCost, \"f\");\n    }\n    /**\n     * Returns how many hint points a player has.\n     */\n    get hintPoints() {\n        return __classPrivateFieldGet(this, _DataManager_hintPoints, \"f\");\n    }\n    /**\n     * Returns the slot data for this game. Will be `undefined` if no connection has been established.\n     */\n    get slotData() {\n        return __classPrivateFieldGet(this, _DataManager_slotData, \"f\");\n    }\n    /**\n     * Returns this player's slot. Returns `-1` if player is not connected.\n     */\n    get slot() {\n        return __classPrivateFieldGet(this, _DataManager_slot, \"f\");\n    }\n    /**\n     * Returns this player's team. Returns `-1` if player is not connected.\n     */\n    get team() {\n        return __classPrivateFieldGet(this, _DataManager_team, \"f\");\n    }\n    /**\n     * Return the seed for this room.\n     */\n    get seed() {\n        return __classPrivateFieldGet(this, _DataManager_seed, \"f\");\n    }\n    /**\n     * Get the current permissions for the room.\n     */\n    get permissions() {\n        return __classPrivateFieldGet(this, _DataManager_permissions, \"f\");\n    }\n    /**\n     * Send a series of set operations to the server. Promise returns a {@link SetReplyPacket} if `want_reply` was\n     * requested.\n     *\n     * @param setOperation The set builder to do operations on the data storage.\n     */\n    set(setOperation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const packet = setOperation.build();\n            if (packet.want_reply) {\n                return new Promise((resolve) => {\n                    __classPrivateFieldGet(this, _DataManager_awaitingSetReplies, \"f\").push({ key: packet.key, resolve });\n                    __classPrivateFieldGet(this, _DataManager_client, \"f\").send(packet);\n                });\n            }\n            else {\n                __classPrivateFieldGet(this, _DataManager_client, \"f\").send(packet);\n            }\n        });\n    }\n}\nexports.DataManager = DataManager;\n_DataManager_client = new WeakMap(), _DataManager_dataPackage = new WeakMap(), _DataManager_players = new WeakMap(), _DataManager_games = new WeakMap(), _DataManager_hintCost = new WeakMap(), _DataManager_hintPoints = new WeakMap(), _DataManager_slotData = new WeakMap(), _DataManager_slot = new WeakMap(), _DataManager_team = new WeakMap(), _DataManager_seed = new WeakMap(), _DataManager_awaitingSetReplies = new WeakMap(), _DataManager_permissions = new WeakMap(), _DataManager_instances = new WeakSet(), _DataManager_onSetReply = function _DataManager_onSetReply(packet) {\n    const replyIndex = __classPrivateFieldGet(this, _DataManager_awaitingSetReplies, \"f\").findIndex((s) => s.key === packet.key);\n    if (replyIndex !== -1) {\n        const { resolve } = __classPrivateFieldGet(this, _DataManager_awaitingSetReplies, \"f\")[replyIndex];\n        // Remove the \"await\".\n        __classPrivateFieldGet(this, _DataManager_awaitingSetReplies, \"f\").splice(replyIndex, 1);\n        resolve(packet);\n    }\n}, _DataManager_onDataPackage = function _DataManager_onDataPackage(packet) {\n    // TODO: Cache results.\n    for (const game in packet.data.games) {\n        const data = packet.data.games[game];\n        __classPrivateFieldGet(this, _DataManager_dataPackage, \"f\").set(game, data);\n        let createItemNameGroup = false;\n        let createLocationNameGroup = false;\n        // Check if these fields exist, if not, let's add them.\n        if (!data.item_name_groups) {\n            data.item_name_groups = { Everything: [] };\n            createItemNameGroup = true;\n        }\n        if (!data.location_name_groups) {\n            data.location_name_groups = { Everywhere: [] };\n            createLocationNameGroup = true;\n        }\n        // Build reverse lookups for items and locations. (also add to Everywhere and Everything group if needed)\n        data.location_id_to_name = {};\n        data.item_id_to_name = {};\n        for (const [name, id] of Object.entries(data.location_name_to_id)) {\n            data.location_id_to_name[id] = name;\n            if (createLocationNameGroup) {\n                data.location_name_groups[\"Everywhere\"].push(name);\n            }\n        }\n        for (const [name, id] of Object.entries(data.item_name_to_id)) {\n            data.item_id_to_name[id] = name;\n            if (createItemNameGroup) {\n                data.item_name_groups[\"Everything\"].push(name);\n            }\n        }\n    }\n}, _DataManager_onConnected = function _DataManager_onConnected(packet) {\n    var _a;\n    // Archipelago player for slot 0 is implicitly the server.\n    const players = [\n        {\n            name: \"Archipelago\",\n            slot: 0,\n            game: \"Archipelago\",\n            team: 0,\n            type: SlotType_1.SLOT_TYPE.SPECTATOR,\n            alias: \"Archipelago\",\n            group_members: [],\n            item: (id) => __classPrivateFieldGet(this, _DataManager_client, \"f\").items.name(0, id),\n            location: (id) => __classPrivateFieldGet(this, _DataManager_client, \"f\").locations.name(0, id),\n        },\n    ];\n    // Add all players.\n    for (const networkPlayer of packet.players) {\n        const player = Object.assign(Object.assign(Object.assign({}, networkPlayer), packet.slot_info[networkPlayer.slot]), { item: (id) => __classPrivateFieldGet(this, _DataManager_client, \"f\").items.name(networkPlayer.slot, id), location: (id) => __classPrivateFieldGet(this, _DataManager_client, \"f\").locations.name(networkPlayer.slot, id) });\n        players[player.slot] = player;\n    }\n    __classPrivateFieldSet(this, _DataManager_players, players, \"f\");\n    __classPrivateFieldSet(this, _DataManager_slot, packet.slot, \"f\");\n    __classPrivateFieldSet(this, _DataManager_team, packet.team, \"f\");\n    __classPrivateFieldSet(this, _DataManager_hintPoints, (_a = packet.hint_points) !== null && _a !== void 0 ? _a : 0, \"f\");\n    __classPrivateFieldSet(this, _DataManager_slotData, packet.slot_data, \"f\");\n}, _DataManager_onRoomInfo = function _DataManager_onRoomInfo(packet) {\n    __classPrivateFieldSet(this, _DataManager_seed, packet.seed_name, \"f\");\n    __classPrivateFieldSet(this, _DataManager_hintCost, packet.hint_cost, \"f\");\n    __classPrivateFieldSet(this, _DataManager_permissions, packet.permissions, \"f\");\n    __classPrivateFieldSet(this, _DataManager_games, packet.games, \"f\");\n    // We are ready to finalize connection.\n    __classPrivateFieldGet(this, _DataManager_client, \"f\").emitRawEvent(\"__onRoomInfoLoaded\");\n}, _DataManager_onRoomUpdate = function _DataManager_onRoomUpdate(packet) {\n    if (packet.hint_points) {\n        __classPrivateFieldSet(this, _DataManager_hintPoints, packet.hint_points, \"f\");\n    }\n    if (packet.hint_cost) {\n        __classPrivateFieldSet(this, _DataManager_hintCost, packet.hint_cost, \"f\");\n    }\n    if (packet.permissions) {\n        __classPrivateFieldSet(this, _DataManager_permissions, packet.permissions, \"f\");\n    }\n    if (packet.players) {\n        for (const player of packet.players) {\n            __classPrivateFieldGet(this, _DataManager_players, \"f\")[player.slot] = Object.assign(Object.assign({}, __classPrivateFieldGet(this, _DataManager_players, \"f\")[player.slot]), player);\n        }\n    }\n};\n//# sourceMappingURL=DataManager.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/managers/DataManager.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/managers/HintsManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/managers/HintsManager.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HintsManager_instances, _HintsManager_client, _HintsManager_hints, _HintsManager_onSetReply, _HintsManager_onRetrieved, _HintsManager_onConnected;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HintsManager = void 0;\nconst CommandPacketType_1 = __webpack_require__(/*! ../consts/CommandPacketType */ \"./node_modules/archipelago.js/dist/consts/CommandPacketType.js\");\n/**\n * Manages and watches for hint events to this player slot and provides helper functions to make working with hints\n * easier.\n */\nclass HintsManager {\n    constructor(client) {\n        _HintsManager_instances.add(this);\n        _HintsManager_client.set(this, void 0);\n        _HintsManager_hints.set(this, []);\n        __classPrivateFieldSet(this, _HintsManager_client, client, \"f\");\n        __classPrivateFieldGet(this, _HintsManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.SET_REPLY, __classPrivateFieldGet(this, _HintsManager_instances, \"m\", _HintsManager_onSetReply).bind(this));\n        __classPrivateFieldGet(this, _HintsManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.RETRIEVED, __classPrivateFieldGet(this, _HintsManager_instances, \"m\", _HintsManager_onRetrieved).bind(this));\n        __classPrivateFieldGet(this, _HintsManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTED, __classPrivateFieldGet(this, _HintsManager_instances, \"m\", _HintsManager_onConnected).bind(this));\n    }\n    /**\n     * Get all hints that are relevant for this slot.\n     */\n    get mine() {\n        return __classPrivateFieldGet(this, _HintsManager_hints, \"f\");\n    }\n}\nexports.HintsManager = HintsManager;\n_HintsManager_client = new WeakMap(), _HintsManager_hints = new WeakMap(), _HintsManager_instances = new WeakSet(), _HintsManager_onSetReply = function _HintsManager_onSetReply(packet) {\n    if (packet.key === `_read_hints_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.team}_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.slot}`) {\n        __classPrivateFieldSet(this, _HintsManager_hints, packet.value, \"f\");\n    }\n}, _HintsManager_onRetrieved = function _HintsManager_onRetrieved(packet) {\n    for (const key in packet.keys) {\n        if (key !== `_read_hints_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.team}_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.slot}`) {\n            continue;\n        }\n        __classPrivateFieldSet(this, _HintsManager_hints, packet.keys[key], \"f\");\n    }\n}, _HintsManager_onConnected = function _HintsManager_onConnected() {\n    // Once connected, let's send out our set_notify for hints.\n    __classPrivateFieldGet(this, _HintsManager_client, \"f\").send({\n        cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.SET_NOTIFY,\n        keys: [`_read_hints_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.team}_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.slot}`],\n    }, {\n        cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.GET,\n        keys: [`_read_hints_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.team}_${__classPrivateFieldGet(this, _HintsManager_client, \"f\").data.slot}`],\n    });\n};\n//# sourceMappingURL=HintsManager.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/managers/HintsManager.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/managers/ItemsManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/managers/ItemsManager.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ItemsManager_instances, _ItemsManager_client, _ItemsManager_items, _ItemsManager_index, _ItemsManager_onReceivedItems;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ItemsManager = void 0;\nconst CommandPacketType_1 = __webpack_require__(/*! ../consts/CommandPacketType */ \"./node_modules/archipelago.js/dist/consts/CommandPacketType.js\");\n/**\n * Manages and watches for events regarding item data and provides helper functions to make working with items easier.\n */\nclass ItemsManager {\n    /**\n     * Creates a new {@link ItemsManager} and sets up events on the {@link Client} to listen for to start\n     * updating its internal state.\n     *\n     * @param client The {@link Client} that should be managing this manager.\n     */\n    constructor(client) {\n        _ItemsManager_instances.add(this);\n        _ItemsManager_client.set(this, void 0);\n        _ItemsManager_items.set(this, []);\n        _ItemsManager_index.set(this, 0);\n        __classPrivateFieldSet(this, _ItemsManager_client, client, \"f\");\n        __classPrivateFieldGet(this, _ItemsManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.RECEIVED_ITEMS, __classPrivateFieldGet(this, _ItemsManager_instances, \"m\", _ItemsManager_onReceivedItems).bind(this));\n    }\n    name(value, id) {\n        if (isNaN(id) || !Number.isSafeInteger(id)) {\n            throw new Error(`'id' must be a safe integer. Received: ${id}`);\n        }\n        let game;\n        if (typeof value === \"string\") {\n            game = value;\n        }\n        else {\n            if (isNaN(value) || !Number.isSafeInteger(value)) {\n                throw new Error(`'player' must be a safe integer. Received: ${id}`);\n            }\n            const player = __classPrivateFieldGet(this, _ItemsManager_client, \"f\").players.get(value);\n            if (!player) {\n                return `Unknown Item: ${id}`;\n            }\n            game = player.game;\n        }\n        const gameData = __classPrivateFieldGet(this, _ItemsManager_client, \"f\").data.package.get(game);\n        if (!gameData) {\n            return `Unknown Item: ${id}`;\n        }\n        const name = gameData.item_id_to_name[id];\n        if (!name) {\n            return `Unknown Item: ${id}`;\n        }\n        return name;\n    }\n    /**\n     * Returns a list of all item names in a given group.\n     *\n     * @param game\n     * @param name\n     *\n     * @throws Throws an error if unable to find game for group in data package.\n     */\n    group(game, name) {\n        const gameData = __classPrivateFieldGet(this, _ItemsManager_client, \"f\").data.package.get(game);\n        if (!gameData) {\n            throw new Error(`Unknown Game: ${game}`);\n        }\n        const group = gameData.item_name_groups[name];\n        if (!group) {\n            return [];\n        }\n        return group;\n    }\n    /**\n     * Returns the current item index. If this value is larger than expected, that means new items have been received.\n     */\n    get index() {\n        return __classPrivateFieldGet(this, _ItemsManager_index, \"f\");\n    }\n    /**\n     * Returns an array of all items that have been received.\n     */\n    get received() {\n        return __classPrivateFieldGet(this, _ItemsManager_items, \"f\");\n    }\n}\nexports.ItemsManager = ItemsManager;\n_ItemsManager_client = new WeakMap(), _ItemsManager_items = new WeakMap(), _ItemsManager_index = new WeakMap(), _ItemsManager_instances = new WeakSet(), _ItemsManager_onReceivedItems = function _ItemsManager_onReceivedItems(packet) {\n    // De-sync occurred! Attempt a re-sync before continuing.\n    if (packet.index > __classPrivateFieldGet(this, _ItemsManager_index, \"f\")) {\n        __classPrivateFieldSet(this, _ItemsManager_index, 0, \"f\");\n        __classPrivateFieldGet(this, _ItemsManager_client, \"f\").send({\n            cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.SYNC,\n        });\n        return;\n    }\n    let index = packet.index;\n    for (const item of packet.items) {\n        __classPrivateFieldGet(this, _ItemsManager_items, \"f\")[index++] = item;\n    }\n};\n//# sourceMappingURL=ItemsManager.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/managers/ItemsManager.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/managers/LocationsManager.js":
/*!***********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/managers/LocationsManager.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LocationsManager_instances, _LocationsManager_client, _LocationsManager_checked, _LocationsManager_missing, _LocationsManager_onConnected, _LocationsManager_onRoomUpdate;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocationsManager = void 0;\nconst CommandPacketType_1 = __webpack_require__(/*! ../consts/CommandPacketType */ \"./node_modules/archipelago.js/dist/consts/CommandPacketType.js\");\nconst CreateAsHintMode_1 = __webpack_require__(/*! ../consts/CreateAsHintMode */ \"./node_modules/archipelago.js/dist/consts/CreateAsHintMode.js\");\n/**\n * Manages and watches for events regarding location data and provides helper functions to make checking, scouting, or\n * working with locations in general easier.\n */\nclass LocationsManager {\n    /**\n     * Creates a new {@link LocationsManager} and sets up events on the {@link Client} to listen for to start\n     * updating its internal state.\n     *\n     * @param client The {@link Client} that should be managing this manager.\n     */\n    constructor(client) {\n        _LocationsManager_instances.add(this);\n        _LocationsManager_client.set(this, void 0);\n        _LocationsManager_checked.set(this, []);\n        _LocationsManager_missing.set(this, []);\n        __classPrivateFieldSet(this, _LocationsManager_client, client, \"f\");\n        __classPrivateFieldGet(this, _LocationsManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.CONNECTED, __classPrivateFieldGet(this, _LocationsManager_instances, \"m\", _LocationsManager_onConnected).bind(this));\n        __classPrivateFieldGet(this, _LocationsManager_client, \"f\").addListener(CommandPacketType_1.SERVER_PACKET_TYPE.ROOM_UPDATE, __classPrivateFieldGet(this, _LocationsManager_instances, \"m\", _LocationsManager_onRoomUpdate).bind(this));\n    }\n    /**\n     * An array of all checked locations.\n     */\n    get checked() {\n        return __classPrivateFieldGet(this, _LocationsManager_checked, \"f\");\n    }\n    /**\n     * An array of all locations that are not checked.\n     */\n    get missing() {\n        return __classPrivateFieldGet(this, _LocationsManager_missing, \"f\");\n    }\n    /**\n     * Check a list of locations and mark the locations as found.\n     *\n     * @param locationIds A list of location ids.\n     */\n    check(...locationIds) {\n        __classPrivateFieldGet(this, _LocationsManager_client, \"f\").send({\n            cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.LOCATION_CHECKS,\n            locations: locationIds,\n        });\n    }\n    /**\n     * Scout a list of locations without marking the locations as found.\n     *\n     * @param hint Create a hint for these locations.\n     * @param locationIds A list of location ids.\n     */\n    scout(hint = CreateAsHintMode_1.CREATE_AS_HINT_MODE.NO_HINT, ...locationIds) {\n        __classPrivateFieldGet(this, _LocationsManager_client, \"f\").send({\n            cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.LOCATION_SCOUTS,\n            locations: locationIds,\n            create_as_hint: hint,\n        });\n    }\n    name(value, id) {\n        if (isNaN(id) || !Number.isSafeInteger(id)) {\n            throw new Error(`'id' must be a safe integer. Received: ${id}`);\n        }\n        let game;\n        if (typeof value === \"string\") {\n            game = value;\n        }\n        else {\n            if (isNaN(value) || !Number.isSafeInteger(value)) {\n                throw new Error(`'player' must be a safe integer. Received: ${id}`);\n            }\n            const player = __classPrivateFieldGet(this, _LocationsManager_client, \"f\").players.get(value);\n            if (!player) {\n                return `Unknown Location: ${id}`;\n            }\n            game = player.game;\n        }\n        const gameData = __classPrivateFieldGet(this, _LocationsManager_client, \"f\").data.package.get(game);\n        if (!gameData) {\n            return `Unknown Location: ${id}`;\n        }\n        const name = gameData.location_id_to_name[id];\n        if (!name) {\n            return `Unknown Location: ${id}`;\n        }\n        return name;\n    }\n    /**\n     * Returns a list of all location names in a given group.\n     *\n     * @param game\n     * @param name\n     *\n     * @throws Throws an error if unable to find game for group in data package.\n     */\n    group(game, name) {\n        const gameData = __classPrivateFieldGet(this, _LocationsManager_client, \"f\").data.package.get(game);\n        if (!gameData) {\n            throw new Error(`Unknown Game: ${game}`);\n        }\n        const group = gameData.location_name_groups[name];\n        if (!group) {\n            return [];\n        }\n        return group;\n    }\n    /**\n     * Sends out all missing locations as checked.\n     */\n    autoRelease() {\n        __classPrivateFieldGet(this, _LocationsManager_client, \"f\").send({\n            cmd: CommandPacketType_1.CLIENT_PACKET_TYPE.LOCATION_CHECKS,\n            locations: __classPrivateFieldGet(this, _LocationsManager_missing, \"f\"),\n        });\n    }\n}\nexports.LocationsManager = LocationsManager;\n_LocationsManager_client = new WeakMap(), _LocationsManager_checked = new WeakMap(), _LocationsManager_missing = new WeakMap(), _LocationsManager_instances = new WeakSet(), _LocationsManager_onConnected = function _LocationsManager_onConnected(packet) {\n    __classPrivateFieldSet(this, _LocationsManager_checked, packet.checked_locations, \"f\");\n    __classPrivateFieldSet(this, _LocationsManager_missing, packet.missing_locations, \"f\");\n}, _LocationsManager_onRoomUpdate = function _LocationsManager_onRoomUpdate(packet) {\n    // Update our checked/missing arrays.\n    if (packet.checked_locations) {\n        for (const location of packet.checked_locations) {\n            if (!__classPrivateFieldGet(this, _LocationsManager_checked, \"f\").includes(location)) {\n                __classPrivateFieldGet(this, _LocationsManager_checked, \"f\").push(location);\n                // Remove from missing locations array as well.\n                const index = __classPrivateFieldGet(this, _LocationsManager_missing, \"f\").indexOf(location);\n                if (index !== -1) {\n                    __classPrivateFieldGet(this, _LocationsManager_missing, \"f\").splice(index, 1);\n                }\n            }\n        }\n    }\n};\n//# sourceMappingURL=LocationsManager.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/managers/LocationsManager.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/managers/PlayersManager.js":
/*!*********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/managers/PlayersManager.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PlayersManager_client;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PlayersManager = void 0;\n/**\n * Manages and watches for events regarding player data and provides helper functions to make working with players\n * easier.\n */\nclass PlayersManager {\n    /**\n     * Creates a new {@link PlayersManager} and sets up events on the {@link Client} to listen for to start\n     * updating its internal state.\n     *\n     * @param client The {@link Client} that should be managing this manager.\n     */\n    constructor(client) {\n        _PlayersManager_client.set(this, void 0);\n        __classPrivateFieldSet(this, _PlayersManager_client, client, \"f\");\n    }\n    /**\n     * Returns an array of all `players`, keyed by player id.\n     */\n    get all() {\n        return __classPrivateFieldGet(this, _PlayersManager_client, \"f\").data.players;\n    }\n    /**\n     * Returns a specific `player` by player id. Returns undefined if player does not exist.\n     */\n    get(id) {\n        return __classPrivateFieldGet(this, _PlayersManager_client, \"f\").data.players[id];\n    }\n    /**\n     * Returns the `name` of a given player `id`. Returns \"Unknown Player #\" if player does not exist in the room.\n     *\n     * Special cases:\n     * - If player id is `0`, returns `Archipelago`.\n     *\n     * @param id The slot `id` of a player.\n     *\n     * @throws Throws an error if unable to find a player with the given `id`.\n     */\n    name(id) {\n        var _a;\n        if (id === 0) {\n            return \"Archipelago\";\n        }\n        const name = (_a = this.get(id)) === null || _a === void 0 ? void 0 : _a.name;\n        if (!name) {\n            throw new Error(`Unable to find player by id: ${id}`);\n        }\n        return name;\n    }\n    /**\n     * Returns the `alias` of a given player `id`. Returns \"Unknown Player #\" if player does not exist in the room.\n     *\n     * Special cases:\n     * - If player id is `0`, returns `Archipelago`.\n     *\n     * @param id The slot `id` of a player.\n     *\n     * @throws Throws an error if unable to find a player with the given `id`.\n     */\n    alias(id) {\n        var _a;\n        if (id === 0) {\n            return \"Archipelago\";\n        }\n        const alias = (_a = this.get(id)) === null || _a === void 0 ? void 0 : _a.alias;\n        if (!alias) {\n            throw new Error(`Unable to find player by id: ${id}`);\n        }\n        return alias;\n    }\n    /**\n     * Returns the game name of a given player.\n     *\n     * Special cases:\n     * - If player id is `0`, returns `Archipelago`.\n     *\n     * @param id The slot `id` of a player.\n     *\n     * @throws Throws an error if unable to find a player with the given `id`.\n     */\n    game(id) {\n        var _a;\n        if (id === 0) {\n            return \"Archipelago\";\n        }\n        const game = (_a = this.get(id)) === null || _a === void 0 ? void 0 : _a.game;\n        if (!game) {\n            throw new Error(`Unable to find player by id: ${id}`);\n        }\n        return game;\n    }\n    /**\n     * Returns an array of player `id`s in a specific group. Returns an empty array for non-{@link SlotType.GROUP}\n     * members.\n     *\n     * @param id The slot `id` of a {@link SlotType.GROUP} player.\n     */\n    members(id) {\n        var _a;\n        const members = (_a = this.get(id)) === null || _a === void 0 ? void 0 : _a.group_members;\n        if (!members) {\n            return [];\n        }\n        return members;\n    }\n}\nexports.PlayersManager = PlayersManager;\n_PlayersManager_client = new WeakMap();\n//# sourceMappingURL=PlayersManager.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/managers/PlayersManager.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/BasePackets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/BasePackets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=BasePackets.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/BasePackets.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/BouncePacket.js":
/*!******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/BouncePacket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=BouncePacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/BouncePacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/BouncedPacket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/BouncedPacket.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=BouncedPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/BouncedPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/ConnectPacket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/ConnectPacket.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ConnectPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/ConnectPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/ConnectUpdatePacket.js":
/*!*************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/ConnectUpdatePacket.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ConnectUpdatePacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/ConnectUpdatePacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/ConnectedPacket.js":
/*!*********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/ConnectedPacket.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ConnectedPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/ConnectedPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/ConnectionRefusedPacket.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/ConnectionRefusedPacket.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ConnectionRefusedPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/ConnectionRefusedPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/DataPackagePacket.js":
/*!***********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/DataPackagePacket.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=DataPackagePacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/DataPackagePacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/GetDataPackagePacket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/GetDataPackagePacket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=GetDataPackagePacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/GetDataPackagePacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/GetPacket.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/GetPacket.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=GetPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/GetPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/InvalidPacketPacket.js":
/*!*************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/InvalidPacketPacket.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=InvalidPacketPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/InvalidPacketPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/LocationChecksPacket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/LocationChecksPacket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=LocationChecksPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/LocationChecksPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/LocationInfoPacket.js":
/*!************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/LocationInfoPacket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=LocationInfoPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/LocationInfoPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/LocationScoutsPacket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/LocationScoutsPacket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=LocationScoutsPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/LocationScoutsPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/PrintJSONPacket.js":
/*!*********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/PrintJSONPacket.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=PrintJSONPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/PrintJSONPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/ReceivedItemsPacket.js":
/*!*************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/ReceivedItemsPacket.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ReceivedItemsPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/ReceivedItemsPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/RetrievedPacket.js":
/*!*********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/RetrievedPacket.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=RetrievedPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/RetrievedPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/RoomInfoPacket.js":
/*!********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/RoomInfoPacket.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=RoomInfoPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/RoomInfoPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/RoomUpdatePacket.js":
/*!**********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/RoomUpdatePacket.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=RoomUpdatePacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/RoomUpdatePacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/SayPacket.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/SayPacket.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=SayPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/SayPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/SetNotifyPacket.js":
/*!*********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/SetNotifyPacket.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=SetNotifyPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/SetNotifyPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/SetPacket.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/SetPacket.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=SetPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/SetPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/SetReplyPacket.js":
/*!********************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/SetReplyPacket.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=SetReplyPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/SetReplyPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/StatusUpdatePacket.js":
/*!************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/StatusUpdatePacket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=StatusUpdatePacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/StatusUpdatePacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/packets/SyncPacket.js":
/*!****************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/packets/SyncPacket.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=SyncPacket.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/packets/SyncPacket.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/ConnectionInformation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/ConnectionInformation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ConnectionInformation.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/ConnectionInformation.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/DataPackage.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/DataPackage.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=DataPackage.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/DataPackage.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/DataStorageOperations.js":
/*!*************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/DataStorageOperations.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=DataStorageOperations.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/DataStorageOperations.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/DeathLinkData.js":
/*!*****************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/DeathLinkData.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=DeathLinkData.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/DeathLinkData.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/GamePackage.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/GamePackage.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=GamePackage.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/GamePackage.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/Hint.js":
/*!********************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/Hint.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=Hint.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/Hint.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/JSONMessagePart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/JSONMessagePart.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VALID_JSON_COLOR_TYPE = exports.VALID_JSON_MESSAGE_TYPE = void 0;\n/**\n * This is a const of all supported message types for denoting the intent of the message part. This can be used to\n * indicate special information which may be rendered differently depending on client.\n *\n * - `text`: Regular text content. Is the default type and as such may be omitted.\n * - `player_id`: Player id of someone on your team, should be resolved to player Name.\n * - `player_name`: Player Name, could be a player within a multiplayer game or from another team, not id resolvable.\n * - `item_id`: Item id, should be resolved to an item name.\n * - `item_name`: Item name, not currently used over network, but supported by reference clients.\n * - `location_id`: Location id, should be resolved to a location name.\n * - `location_name`: Location name, not currently used over network, but supported by reference clients.\n * - `entrance_name`: Entrance name. No id mapping exists.\n * - `color`: Regular text that should be colored. Only type that will contain color data.\n */\nexports.VALID_JSON_MESSAGE_TYPE = {\n    TEXT: \"text\",\n    PLAYER_ID: \"player_id\",\n    PLAYER_NAME: \"player_name\",\n    ITEM_ID: \"item_id\",\n    ITEM_NAME: \"item_name\",\n    LOCATION_ID: \"location_id\",\n    LOCATION_NAME: \"location_name\",\n    ENTRANCE_NAME: \"entrance_name\",\n    COLOR: \"color\",\n};\n/**\n * This is a const of all supported \"colors\" denoting a console color to display the message part with and is only\n * sent if the `type` is `color`. This is limited to console colors due to backwards compatibility needs with games such\n * as `A Link to the Past`. Although background colors as well as foreground colors are listed, only one may be applied\n * to a {@link JSONMessagePart} at a time.\n */\nexports.VALID_JSON_COLOR_TYPE = {\n    // Yes, 'bold' and 'underline' are colors. Deal with it.\n    BOLD: \"bold\",\n    UNDERLINE: \"underline\",\n    BLACK: \"black\",\n    RED: \"red\",\n    GREEN: \"green\",\n    YELLOW: \"yellow\",\n    BLUE: \"blue\",\n    MAGENTA: \"magenta\",\n    CYAN: \"cyan\",\n    WHITE: \"white\",\n    BLACK_BACKGROUND: \"black_bg\",\n    RED_BACKGROUND: \"red_bg\",\n    GREEN_BACKGROUND: \"green_bg\",\n    YELLOW_BACKGROUND: \"yellow_bg\",\n    BLUE_BACKGROUND: \"blue_bg\",\n    PURPLE_BACKGROUND: \"purple_bg\",\n    CYAN_BACKGROUND: \"cyan_bg\",\n    WHITE_BACKGROUND: \"white_bg\",\n};\n//# sourceMappingURL=JSONMessagePart.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/JSONMessagePart.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/JSONSerializableData.js":
/*!************************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/JSONSerializableData.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=JSONSerializableData.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/JSONSerializableData.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/NetworkItem.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/NetworkItem.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=NetworkItem.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/NetworkItem.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/NetworkPlayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/NetworkPlayer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=NetworkPlayer.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/NetworkPlayer.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/NetworkSlot.js":
/*!***************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/NetworkSlot.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=NetworkSlot.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/NetworkSlot.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/NetworkVersion.js":
/*!******************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/NetworkVersion.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=NetworkVersion.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/NetworkVersion.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/ObjectValues.js":
/*!****************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/ObjectValues.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ObjectValues.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/ObjectValues.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/Player.js":
/*!**********************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/Player.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=Player.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/Player.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/SlotData.js":
/*!************************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/SlotData.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=SlotData.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/SlotData.js?");

/***/ }),

/***/ "./node_modules/archipelago.js/dist/types/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/archipelago.js/dist/types/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./ConnectionInformation */ \"./node_modules/archipelago.js/dist/types/ConnectionInformation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./DataPackage */ \"./node_modules/archipelago.js/dist/types/DataPackage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./DataStorageOperations */ \"./node_modules/archipelago.js/dist/types/DataStorageOperations.js\"), exports);\n__exportStar(__webpack_require__(/*! ./DeathLinkData */ \"./node_modules/archipelago.js/dist/types/DeathLinkData.js\"), exports);\n__exportStar(__webpack_require__(/*! ./GamePackage */ \"./node_modules/archipelago.js/dist/types/GamePackage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Hint */ \"./node_modules/archipelago.js/dist/types/Hint.js\"), exports);\n__exportStar(__webpack_require__(/*! ./JSONMessagePart */ \"./node_modules/archipelago.js/dist/types/JSONMessagePart.js\"), exports);\n__exportStar(__webpack_require__(/*! ./JSONSerializableData */ \"./node_modules/archipelago.js/dist/types/JSONSerializableData.js\"), exports);\n__exportStar(__webpack_require__(/*! ./NetworkItem */ \"./node_modules/archipelago.js/dist/types/NetworkItem.js\"), exports);\n__exportStar(__webpack_require__(/*! ./NetworkPlayer */ \"./node_modules/archipelago.js/dist/types/NetworkPlayer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./NetworkSlot */ \"./node_modules/archipelago.js/dist/types/NetworkSlot.js\"), exports);\n__exportStar(__webpack_require__(/*! ./NetworkVersion */ \"./node_modules/archipelago.js/dist/types/NetworkVersion.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ObjectValues */ \"./node_modules/archipelago.js/dist/types/ObjectValues.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Player */ \"./node_modules/archipelago.js/dist/types/Player.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SlotData */ \"./node_modules/archipelago.js/dist/types/SlotData.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/archipelago.js/dist/types/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/isomorphic-ws/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/isomorphic-ws/browser.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof __webpack_require__.g !== 'undefined') {\n  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ws);\n\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/isomorphic-ws/browser.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"NIL\", ({\n  enumerable: true,\n  get: function get() {\n    return _nil.default;\n  }\n}));\nObject.defineProperty(exports, \"parse\", ({\n  enumerable: true,\n  get: function get() {\n    return _parse.default;\n  }\n}));\nObject.defineProperty(exports, \"stringify\", ({\n  enumerable: true,\n  get: function get() {\n    return _stringify.default;\n  }\n}));\nObject.defineProperty(exports, \"v1\", ({\n  enumerable: true,\n  get: function get() {\n    return _v.default;\n  }\n}));\nObject.defineProperty(exports, \"v3\", ({\n  enumerable: true,\n  get: function get() {\n    return _v2.default;\n  }\n}));\nObject.defineProperty(exports, \"v4\", ({\n  enumerable: true,\n  get: function get() {\n    return _v3.default;\n  }\n}));\nObject.defineProperty(exports, \"v5\", ({\n  enumerable: true,\n  get: function get() {\n    return _v4.default;\n  }\n}));\nObject.defineProperty(exports, \"validate\", ({\n  enumerable: true,\n  get: function get() {\n    return _validate.default;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function get() {\n    return _version.default;\n  }\n}));\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/commonjs-browser/v1.js\"));\n\nvar _v2 = _interopRequireDefault(__webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/commonjs-browser/v3.js\"));\n\nvar _v3 = _interopRequireDefault(__webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/commonjs-browser/v4.js\"));\n\nvar _v4 = _interopRequireDefault(__webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/commonjs-browser/v5.js\"));\n\nvar _nil = _interopRequireDefault(__webpack_require__(/*! ./nil.js */ \"./node_modules/uuid/dist/commonjs-browser/nil.js\"));\n\nvar _version = _interopRequireDefault(__webpack_require__(/*! ./version.js */ \"./node_modules/uuid/dist/commonjs-browser/version.js\"));\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nvar _stringify = _interopRequireDefault(__webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\"));\n\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/md5.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/md5.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nvar _default = md5;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/md5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/native.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/native.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar _default = {\n  randomUUID\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/nil.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/nil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/nil.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/parse.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/parse.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/regex.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/regex.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/rng.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/rng.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = rng;\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/sha1.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/sha1.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nvar _default = sha1;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/sha1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/stringify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.unsafeStringify = unsafeStringify;\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v1.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v1.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/commonjs-browser/rng.js\"));\n\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.unsafeStringify)(b);\n}\n\nvar _default = v1;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v3.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v3.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/commonjs-browser/v35.js\"));\n\nvar _md = _interopRequireDefault(__webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/commonjs-browser/md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/v3.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v35.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v35.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.URL = exports.DNS = void 0;\nexports[\"default\"] = v35;\n\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\n\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/v35.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v4.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v4.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _native = _interopRequireDefault(__webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/commonjs-browser/native.js\"));\n\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/commonjs-browser/rng.js\"));\n\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  if (_native.default.randomUUID && !buf && !options) {\n    return _native.default.randomUUID();\n  }\n\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.unsafeStringify)(rnds);\n}\n\nvar _default = v4;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v5.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v5.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/commonjs-browser/v35.js\"));\n\nvar _sha = _interopRequireDefault(__webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/commonjs-browser/sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/v5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/validate.js":
/*!*************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/validate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _regex = _interopRequireDefault(__webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/commonjs-browser/regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/validate.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/version.js":
/*!************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/version.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\nvar _default = version;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./node_modules/uuid/dist/commonjs-browser/version.js?");

/***/ }),

/***/ "./src/puzzles.js":
/*!************************!*\
  !*** ./src/puzzles.js ***!
  \************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n    Client, ITEMS_HANDLING_FLAGS, SERVER_PACKET_TYPE, LocationsManager, ReceivedItemsPacket,\n    CLIENT_STATUS\n} = __webpack_require__(/*! archipelago.js */ \"./node_modules/archipelago.js/dist/index.js\");\nconst Alpine = (__webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/module.esm.js\")[\"default\"]);\nconst SaveData = __webpack_require__(/*! ./savedata.js */ \"./src/savedata.js\");\nconst {GameSave, getFile, getFileList, openDatabase} = SaveData;\n\nconst genres = [\n    \"blackbox\",\"bridges\",\"cube\",\"dominosa\",\"fifteen\",\"filling\",\"flip\",\"flood\",\"galaxies\",\n    \"group\",\"guess\",\"inertia\",\"keen\",\"lightup\",\"loopy\",\"magnets\",\"map\",\"mines\",\"mosaic\",\"net\",\n    \"netslide\",\"palisade\",\"pattern\",\"pearl\",\"pegs\",\"range\",\"rect\",\"samegame\",\"signpost\",\n    \"singles\",\"sixteen\",\"slant\",\"solo\",\"tents\",\"towers\",\"tracks\",\"twiddle\",\"undead\",\n    \"unequal\",\"unruly\",\"untangle\"\n]\n\ndocument.addEventListener(\"alpine:init\", onInit)\n\nlet puzzleframe;\nlet apReady = false;\n\n/**\n * @type{Client}\n */\nlet client;\n\nclass ArchipelagoPuzzle {\n    constructor(options) {\n        // Puzzle genre\n        this.genre = options.genre;\n\n        // Puzzle generation options (size, difficulty, etc.)\n        this.params = options.params;\n\n        // Human-readable puzzle description\n        this.desc = \"\";\n\n        // Puzzle number; also Archipelago region/item number\n        this.index = options.index;\n\n        // Puzzle id (params:data)\n        this.puzzleId = options.puzzleId;\n\n        // Puzzle seed (genParams#seed)\n        this.puzzleSeed = options.puzzleSeed;\n\n        this.solved = options.solved ?? false;\n        this.collected = options.collected ?? false;\n        this.locked = options.locked ?? false;\n        this.item = options.item;\n        this.state = \"\";\n\n        this.updateDescription();\n        this.updateState();\n    }\n\n    updateDescription() {\n        this.desc = `${this.genre}: ${this.params}`;\n    }\n\n    updateState() {\n        if (this.locked) {\n            this.state = \"locked\";\n        } else if (this.solved) {\n            this.state = \"solved\";\n        } else {\n            this.state = \"unlocked\";\n        }\n    }\n\n    onSolve() {\n        this.solved = true;\n        this.updateState();\n\n        // TODO should probably extract this somewhere\n        if (apReady) {\n            let locationId = this.index - 1 + 925000;\n\n            client.locations.check(locationId);\n        }\n    }\n\n    static fromArchipelagoString(genreAndParams, baseSeed, index, options) {\n        let seedPrefix = \"\"+index;\n        seedPrefix = seedPrefix.padStart(3, \"0\");\n        let seed = `${seedPrefix}${baseSeed}`;\n\n        let genreParamsMatch = /^([^:]*)(:(.*))?$/.exec(genreAndParams);\n\n        options ??= {};\n\n        options.genre = genreParamsMatch[1];\n        options.params = genreParamsMatch[3] ?? \"\";\n        options.puzzleSeed = `${options.params}#${seed}`;\n        options.index = index;\n\n        return new ArchipelagoPuzzle(options);\n    }\n\n    static fromPuzzlesString(genre, seedOrId, index, options) {\n        options ??= {};\n\n        if (seedOrId) {\n            let paramsSeparatorMatch = /^([^:#]*)([:#]?)/.exec(seedOrId);\n\n            options.params = paramsSeparatorMatch[1];\n            let separator = paramsSeparatorMatch[2];\n\n            if (separator == \":\") {\n                options.puzzleId = seedOrId;\n            } else {\n                // also treat string with no separator as seed\n                options.puzzleSeed = seedOrId;\n            }\n        } else {\n            options.params = \"\";\n        }\n\n        options.index ??= index;\n        options.genre = genre;\n\n        return new ArchipelagoPuzzle(options);\n    }\n}\n\nfunction sendMessage(command, ...args) {\n    if (puzzleframe) {\n        puzzleframe.contentWindow.postMessage([command, ...args])\n    }\n}\n\nfunction onInit() {\n    console.log(\"puzzles.html: onInit\")\n\n    async function initSaveData() {\n        await openDatabase()\n        console.log(\"Savedata open\")\n        await loadFileList()\n        console.log(\"File list loaded\")\n    }\n\n    initSaveData();\n\n    initStores()\n\n    // Set up puzzleframe\n    puzzleframe = document.getElementById(\"puzzleframe\");\n\n    // puzzleframe will send [\"ready\"] when initialization is done\n}\n\n/**\n * First-time initialization for puzzle data Alpine stores.\n */\nfunction initStores() {\n    // List of available puzzles from Archipelago\n    Alpine.store(\"puzzleList\", {\n        entries: genres.filter(e => e != \"group\").map((genre,i) => ArchipelagoPuzzle.fromPuzzlesString(genre, \"\", i+1)),\n        sortedEntries: [],\n        currentIndex: -1,\n        current: null,\n        solveCount: 0,\n        solveTarget: null,\n        selectPuzzle(entry) {\n            if (!entry) {\n                this.currentIndex = -1;\n                this.current = null;\n                return;\n            }\n\n            if ((entry.locked && !Alpine.store(\"debugMode\")) || entry.index == this.currentIndex) {\n                return;\n            }\n\n            this.currentIndex = entry.index;\n            this.current = entry;\n            if (entry.puzzleId) {\n                loadPuzzle(entry.genre, entry.puzzleId, true);\n            } else if (entry.puzzleSeed) {\n                loadPuzzle(entry.genre, entry.puzzleSeed, true);\n            } else {\n                loadPuzzle(entry.genre, \"\", false);\n            }\n        },\n        markSolved() {\n            if (this.current) {\n                this.current.onSolve();\n\n                const gamesaves = Alpine.store(\"gamesaves\")\n\n                if (this.current.index && gamesaves.current) {\n                    savePuzzleData();\n                    gamesaves.current.puzzleSolved[this.current.index-1] = true;\n                    gamesaves.current.save();\n                }\n\n                this.resort();\n            }\n        },\n        resort() {\n            // Helper comparison function\n            // 0 if a == b; -1 if a < b; 1 if a > b\n            // Can be chained with ||\n            // Note: this sorts \"false\" before \"true\"\n            function compare(a,b) {\n                if (a < b) return -1;\n                else if (a > b) return 1;\n                else return 0;\n            }\n\n            function sortKey(entry) {\n                if (entry.solved) return 1;\n                else if (entry.locked) return 2;\n                else return 0;\n            }\n\n            var sortedEntries = this.entries.slice();\n            \n            sortedEntries.sort((a,b) => compare(sortKey(a), sortKey(b)))\n\n            this.sortedEntries = sortedEntries;\n\n            this.solveCount = this.entries.reduce((a,b) => (b.solved ? a+1 : a), 0)\n        },\n        onFinishClick() {\n            if (this.solveTarget !== null && this.solveCount >= this.solveTarget) {\n                client.updateStatus(CLIENT_STATUS.GOAL);\n            }\n        }\n    })\n\n    Alpine.store(\"puzzleList\").resort();\n\n    // Various information about the current puzzle\n    Alpine.store(\"puzzleState\", {\n        onSolve() {\n            this.solved = true;\n        },\n        undoEnabled: false,\n        redoEnabled: false,\n        solveEnabled: true,\n        primaryKeyLabel: \"\",\n        secondaryKeyLabel: \"\",\n        solved: false,\n        status: 0,\n        gameId: \"\",\n        gameSeed: \"\",\n        reset() {\n            this.solved = false;\n            this.undoEnabled = false;\n            this.redoEnabled = false;\n            this.solveEnabled = true;\n            this.primaryKeyLabel = \"\";\n            this.secondaryKeyLabel = \"\";\n            this.status = 0;\n            this.gameId = \"\";\n            this.gameSeed = \"\";\n        }\n    })\n\n    // A variable to store whether the current puzzle should be played as a fixed puzzle\n    // (i.e. disable the Solve button and new game shortcuts)\n    Alpine.store(\"singleMode\", false)\n\n    // List of presets for the current puzzle\n    // [{id: Int, name: String}]\n    Alpine.store(\"puzzlePresets\", [])\n\n    // Dialog box displayed by puzzle midend\n    Alpine.store(\"puzzleDialog\", {\n        controls: [],\n        visible: false,\n        addControl(index, type, title, initialValue, choices) {\n            if (type == \"choice\") {\n                this.controls.push({index, type, title, value: initialValue, choices})\n            } else {\n                this.controls.push({index, type, title, value: initialValue})\n            }\n        },\n        confirm: dialogConfirm,\n        cancel: dialogCancel,\n        dismiss() {\n            this.controls = [];\n            this.visible = false;\n        }\n    })\n\n    // Error message displayed by puzzle midend\n    Alpine.store(\"errorMessage\", {\n        message: \"\",\n        visible: false,\n        show(message) {\n            this.message = message;\n            this.visible = true;\n        },\n        dismiss() {\n            this.visible = false;\n        }\n    })\n\n    // Puzzle status bar\n    Alpine.store(\"status\", {\n        message: \"\",\n        visible: false,\n        set(value) {\n            this.message = value;\n            this.visible = true;\n        },\n        hide() {\n            this.message = \"\";\n            this.visible = false;\n        }\n    })\n\n    // Widget to load puzzles on-demand\n    // TODO make this with proper UI\n    Alpine.store(\"debugLoader\", {\n        genre: \"net\",\n        id: \"\",\n        singleMode: false,\n        load() {\n            Alpine.store(\"puzzleList\").selectPuzzle(null);\n            loadPuzzle(this.genre, this.id, this.singleMode);\n        }\n    })\n\n    Alpine.store(\"connectionInfo\", {\n        hostname: \"localhost\",\n        port: \"38281\",\n        player: \"Player1\",\n        connect() {\n            createFile(this.hostname, +this.port, this.player);\n        }\n    })\n\n    // TODO a lot of this should be moved to connectionInfo (possibly all of it)\n    Alpine.store(\"gamesaves\", {\n        list: [],\n        current: null,\n        apError: false,\n        connecting: false,\n        loadFile(file) {\n            loadFile(file);\n        },\n        deleteFile(file) {\n            // TODO proper confirmation dialog\n            if (confirm(`${file.toString()}: Delete this file?`)) {\n                deleteFile(file)\n            }\n        }\n    })\n\n    Alpine.store(\"genres\", genres)\n\n    resetPuzzleMetadata();\n}\n\n/**\n * Reset all puzzle metadata when loading a new puzzle.\n */\nfunction resetPuzzleMetadata() {\n    Alpine.store(\"puzzleState\").reset();\n    Alpine.store(\"puzzlePresets\", []);\n    Alpine.store(\"puzzleDialog\").dismiss();\n    Alpine.store(\"status\").hide();\n    Alpine.store(\"errorMessage\").dismiss();\n}\n\nasync function loadPuzzle(genre, id, singleMode) {\n    let debugLoader = Alpine.store(\"debugLoader\");\n\n    if (!genre) {\n        id = undefined;\n        singleMode = true;\n    }\n\n    debugLoader.genre = genre;\n    debugLoader.id = id;\n    debugLoader.singleMode = !!singleMode;\n\n    Alpine.store(\"singleMode\", !!singleMode)\n\n    const puzzleFrameBase = \"puzzleframe.html\";\n\n    const gamesaves = Alpine.store(\"gamesaves\");\n\n    let hasSave = false;\n\n    if (gamesaves.current && id) {\n        let saveData = await gamesaves.current.getPuzzleSave(id);\n        if (saveData) {\n            hasSave = true;\n        }\n    }\n\n    let queryFragments = [];\n\n    if (genre) {\n        queryFragments.push({key: \"g\", value: genre});\n    }\n    // Don't bother sending ID if save data exists\n    if (id && !hasSave) {\n        queryFragments.push({key: \"i\", value: id});\n    }\n    if (singleMode || !genre) {\n        queryFragments.push({key: \"s\", value: \"true\"});\n    }\n\n    let queryString = queryFragments.map(e => `${e.key}=${encodeURIComponent(e.value)}`).join(\"&\");\n\n    puzzleframe.src = null;\n    puzzleframe.src = `${puzzleFrameBase}?${queryString}`;\n}\n\nasync function clearPuzzle() {\n    return await loadPuzzle(\"\");\n}\n\n//\n// puzzleFrame message handlers\n//\n\nfunction onPuzzleFrameLoad() {\n    console.log(\"puzzles.html: puzzleframe ready\")\n    resetPuzzleMetadata();\n}\n\nfunction js_init_puzzle() {\n    \n}\n\nfunction js_post_init() {\n    loadPuzzleData();\n}\n\nfunction js_enable_undo_redo(enableUndo, enableRedo) {\n    Alpine.store(\"puzzleState\").undoEnabled = !!enableUndo\n    Alpine.store(\"puzzleState\").redoEnabled = !!enableRedo\n}\n\nfunction js_remove_solve_button() {\n    Alpine.store(\"puzzleState\").solveEnabled = false;\n}\n\nfunction js_update_permalinks(gameId, gameSeed) {\n    let puzzleState = Alpine.store(\"puzzleState\");\n    puzzleState.gameId = gameId;\n    puzzleState.gameSeed = gameSeed;\n}\n\nfunction js_update_status(newStatus) {\n    let puzzleState = Alpine.store(\"puzzleState\");\n    puzzleState.status = newStatus;\n    if (puzzleState.status == 1 && !puzzleState.solved) {\n        console.log(\"woo hoo\")\n        puzzleState.solved = true\n        Alpine.store(\"puzzleList\").markSolved()\n    }\n}\n\nfunction js_update_key_labels(pcl, scl) {\n    let puzzleState = Alpine.store(\"puzzleState\");\n    puzzleState.primaryKeyLabel = pcl;\n    puzzleState.secondaryKeyLabel = scl;\n}\n\nfunction js_add_preset(menuId, name, id) {\n    let newPreset = {menuId, name, id}\n    Alpine.store(\"puzzlePresets\").push(newPreset)\n}\n\nfunction js_add_preset_submenu() {\n    // Deal with this later\n}\n\nfunction js_select_preset(id) {\n    // idk\n}\n\nfunction js_dialog_init() {\n    const dialog = Alpine.store(\"puzzleDialog\");\n    dialog.controls = [];\n}\n\nfunction js_dialog_string(index, title, initvalue) {\n    Alpine.store(\"puzzleDialog\").addControl(index, \"string\", title, initvalue)\n}\n\nfunction js_dialog_choices(index, title, choiceStr, initvalue) {\n    // Split choiceStr by its first character\n    let choices = choiceStr.split(choiceStr[0])\n    choices.shift()\n\n    Alpine.store(\"puzzleDialog\").addControl(index, \"choice\", title, initvalue, choices)\n}\n\nfunction js_dialog_boolean(index, title, initvalue) {\n    Alpine.store(\"puzzleDialog\").addControl(index, \"boolean\", title, !!initvalue)\n}\n\nfunction js_dialog_launch() {\n    Alpine.store(\"puzzleDialog\").visible = true;\n}\n\nfunction js_dialog_cleanup() {\n    Alpine.store(\"puzzleDialog\").dismiss();\n}\n\nfunction js_canvas_set_statusbar(value) {\n    Alpine.store(\"status\").set(value);\n}\n\nfunction js_canvas_remove_statusbar() {\n    Alpine.store(\"status\").hide();\n}\n\nfunction js_canvas_set_size(w, h) {\n\n}\n\nfunction js_focus_canvas() {\n\n}\n\nfunction js_error_box(message) {\n    Alpine.store(\"errorMessage\").show(message)\n}\n\nfunction savePuzzleDataCallback(data) {\n    console.log(\"Save file ready\")\n    \n    const gamesaves = Alpine.store(\"gamesaves\");\n    const puzzleList = Alpine.store(\"puzzleList\");\n    if (!gamesaves.current || !puzzleList.current) return;\n\n    gamesaves.current.setPuzzleSave(puzzleList.current.index, data)\n}\n\nconst messageHandlers = {\n    ready: onPuzzleFrameLoad, js_init_puzzle, js_post_init,\n    js_update_permalinks, js_enable_undo_redo, js_remove_solve_button, js_update_status, js_update_key_labels,\n    js_add_preset, js_add_preset_submenu, js_select_preset,\n    js_dialog_init, js_dialog_string, js_dialog_choices, js_dialog_boolean, js_dialog_launch, js_dialog_cleanup,\n    js_canvas_set_statusbar, js_canvas_remove_statusbar, js_canvas_set_size, js_error_box, js_focus_canvas,\n    savePuzzleDataCallback\n}\n\nfunction processMessage(message) {\n    if (!message.data[Symbol.iterator]) return;\n\n    let [command, ...args] = message.data\n\n    if (command) {\n        let handler = messageHandlers[command]\n        if (handler) {\n            handler(...args)\n        } else {\n            console.log(\"to puzzles.html:\", message.data)\n            console.warn(\"No handler found for message\", message.data[0])\n        }\n    }\n}\n\nwindow.onmessage = processMessage\n\n//\n// UI functions\n//\n\nfunction showPreferences() {\n    sendMessage(\"showPreferences\");\n}\n\nfunction newPuzzle() {\n    sendMessage(\"newPuzzle\");\n    Alpine.store(\"puzzleState\").solved = false;\n}\n\nfunction restartPuzzle() {\n    sendMessage(\"restartPuzzle\");\n}\n\nfunction undoPuzzle() {\n    sendMessage(\"undoPuzzle\");\n}\n\nfunction redoPuzzle() {\n    sendMessage(\"redoPuzzle\");\n}\n\nfunction solvePuzzle() {\n    sendMessage(\"solvePuzzle\");\n\n    // Mark puzzle as solved regardless of whether the puzzle was actually solved\n\n    Alpine.store(\"puzzleList\").markSolved()\n}\n\nfunction setPreset(id) {\n    sendMessage(\"setPreset\", id)\n}\n\nfunction dialogConfirm() {\n    let dialog = Alpine.store(\"puzzleDialog\");\n    for (let elem of dialog.controls) {\n        switch (elem.type) {\n            case \"string\":\n                sendMessage(\"dialogReturnString\", elem.index, elem.value); break;\n            case \"choice\":\n                sendMessage(\"dialogReturnInt\", elem.index, elem.value); break;\n            case \"boolean\":\n                sendMessage(\"dialogReturnInt\", elem.index, elem.value ? 1 : 0); break;\n        }\n    }\n    sendMessage(\"dialogConfirm\")\n}\n\nfunction dialogCancel() {\n    sendMessage(\"dialogCancel\")\n}\n\nfunction savePuzzleData() {\n    sendMessage(\"savePuzzleData\")\n}\n\nasync function loadPuzzleData() {\n    const gamesaves = Alpine.store(\"gamesaves\");\n    const puzzleList = Alpine.store(\"puzzleList\");\n    if (!gamesaves.current || !puzzleList.current) return;\n\n    let data = await gamesaves.current.getPuzzleSave(puzzleList.current.index);\n\n    if (data) {\n        sendMessage(\"loadPuzzleData\", data);\n    }\n}\n\nfunction hasItem(itemId) {\n    return client.items.received.findIndex(e => e.item == itemId) > -1;\n}\n\nfunction syncAPStatus() {\n    const puzzleList = Alpine.store(\"puzzleList\");\n\n    if (!apReady) {\n        puzzleList.resort();\n        return;\n    };\n\n    const gamesaves = Alpine.store(\"gamesaves\");\n\n    let allSolved = true;\n    let currentFile = gamesaves.current;\n\n    let fileDirty = false;\n\n    for (let entry of puzzleList.entries) {\n        let dirty = false;\n        let itemId = entry.index - 1 + 925000;\n        let locationId = itemId;\n\n        if (!entry.collected && client.locations.checked.includes(locationId)) {\n            entry.collected = true;\n            dirty = true;\n        } else if (!entry.collected) {\n            allSolved = false;\n        }\n\n        if (entry.locked && hasItem(itemId)) {\n            entry.locked = false;\n            dirty = true;\n\n            if (currentFile && currentFile.puzzleLocked[entry.index-1]) {\n                currentFile.puzzleLocked[entry.index-1] = false;\n                fileDirty = true;\n            }\n        }\n\n        if (dirty) {\n            entry.updateState();\n        }\n    }\n\n    puzzleList.resort();\n\n    if (fileDirty) {\n        currentFile.save();\n    }\n}\n\nasync function createFile(hostname, port, player) {\n    const gamesaves = Alpine.store(\"gamesaves\")\n    gamesaves.connecting = true;\n\n    disconnectAP();\n\n    gamesaves.apError = false;\n\n    try {\n        await connectAP(hostname, port, player);\n    } catch (e) {\n        alert(\"Couldn't connect to Archipelago server.\");\n        console.error(\"Couldn't connect to Archipelago server\");\n        console.error(e);\n\n        gamesaves.apError = true;\n        gamesaves.connecting = false;\n\n        return;\n    }\n\n    let slotData = client.data.slotData;\n\n    let newFile = new GameSave({\n        host: hostname,\n        port: port,\n        player: player,\n        puzzles: slotData.puzzles,\n        baseSeed: \"\" + slotData.world_seed,\n        solveTarget: slotData.solve_target\n    });\n\n    await clearPuzzle();\n\n    loadFileData(newFile);\n\n    await newFile.save();\n\n    apReady = true;\n    gamesaves.connecting = false;\n    gamesaves.list.push(newFile);\n    gamesaves.current = newFile;\n    syncAPStatus();\n}\n\n/**\n * \n * @param {SaveData.GameSave} file \n */\nasync function loadFile(file) {\n    const gamesaves = Alpine.store(\"gamesaves\")\n    gamesaves.connecting = true;\n    gamesaves.current = file;\n\n    disconnectAP();\n\n    gamesaves.apError = false;\n    let connectOk = false;\n\n    if (file.host) {\n        try {\n            await connectAP(file.host, file.port, file.player);\n            connectOk = true;\n        } catch (e) {\n            alert(\"Couldn't connect to Archipelago server. (You can still solve unlocked puzzles on this file.)\")\n            gamesaves.apError = true;\n            console.error(e);\n        }\n    }\n\n    if (connectOk) {\n        // Verify puzzle list and seed match\n        function anyMismatch() {\n            let slotData = client.data.slotData;\n\n            if (file.baseSeed != \"\" + slotData.world_seed) return true;\n            if (file.puzzles.length != slotData.puzzles.length) return true;\n\n            for (let i = 0; i < file.puzzles.length; i++) {\n                if (file.puzzles[i] != slotData.puzzles[i]) return true;\n            }\n\n            return false;\n        }\n\n        if (anyMismatch()) {\n            alert(\"The Archipelago server data doesn't match this save file. (You can still solve unlocked puzzles.)\")\n            disconnectAP();\n            connectOk = false;\n            gamesaves.apError = true;\n        }\n    }\n\n    await clearPuzzle();\n\n    loadFileData(file);\n\n    if (connectOk) {\n        apReady = true;\n    }\n\n    gamesaves.connecting = false;\n    syncAPStatus();\n}\n\nasync function deleteFile(file) {\n    await file.deleteFile();\n    \n    const gamesaves = Alpine.store(\"gamesaves\");\n    const puzzleList = Alpine.store(\"puzzleList\");\n\n    let index = gamesaves.list.indexOf(file);\n    if (index > -1) {\n        gamesaves.list.splice(index, 1);\n    }\n\n    if (gamesaves.current == file) {\n        // TODO extract this\n        clearPuzzle();\n        gamesaves.current = null;\n        loadFileData(null);\n    }\n}\n\nasync function loadFileList() {\n    const gamesaves = Alpine.store(\"gamesaves\");\n    gamesaves.list = await getFileList();\n\n    // let defaultGame = new GameSave({\n    //     puzzles: genres.slice()\n    // })\n\n    // gamesaves.list.unshift(defaultGame)\n}\n\nfunction onReceiveItems(event) {\n    if (apReady) {\n        syncAPStatus();\n    }\n}\n\nfunction logEvent(event) {\n    console.log(event);\n}\n\nasync function connectAP(hostname, port, player) {\n    if (!client) {\n        client = new Client();\n        window.client = client;\n    }\n\n    // TODO probably unnecessary to sync both due to ReceivedItems and RoomUpdate..?\n    client.addListener(\"ReceivedItems\", onReceiveItems);\n    client.addListener(\"RoomUpdate\", syncAPStatus);\n    client.addListener(\"PacketReceived\", logEvent);\n\n    console.log(\"connecting to AP...\");\n\n    const connectionInfo = {\n        hostname: hostname,\n        port: port,\n        game: \"Simon Tatham's Portable Puzzle Collection\",\n        name: player,\n        items_handling: ITEMS_HANDLING_FLAGS.REMOTE_ALL,\n    };\n\n    await client.connect(connectionInfo);\n\n    console.log(\"connected to AP\");\n}\n\n/**\n * \n * @param {SaveData.GameSave} file\n */\nfunction loadFileData(file) {\n    const puzzleList = Alpine.store(\"puzzleList\");\n\n    // TODO styling sometimes doesn't update when reconnecting while a puzzle is selected.\n    // Seems like a bug with Alpine (or with how I'm using it), I'll probably have to switch to a different\n    // UI/reactivity library\n    puzzleList.entries = [];\n    puzzleList.sortedEntries = [];\n    puzzleList.selectPuzzle(null);\n    puzzleList.solveTarget = file?.solveTarget ?? null;\n\n    if (file) {\n        for (let i = 0; i < file.puzzles.length; i++) {\n            let options = {locked: file.puzzleLocked[i], solved: file.puzzleSolved[i]}\n\n            let newEntry = ArchipelagoPuzzle.fromArchipelagoString(file.puzzles[i], file.baseSeed, i+1, options)\n\n            puzzleList.entries.push(newEntry);\n        }\n    }\n\n    puzzleList.resort();\n}\n\nfunction disconnectAP() {\n    if (client) {\n        apReady = false;\n        console.log(\"disconnecting from AP...\");\n        client.disconnect();\n    }\n}\n\n// Expose UI functions to global scope\n// I should probably move these to Alpine\nwindow.showPreferences = showPreferences;\nwindow.newPuzzle = newPuzzle;\nwindow.restartPuzzle = restartPuzzle;\nwindow.undoPuzzle = undoPuzzle;\nwindow.redoPuzzle = redoPuzzle;\nwindow.solvePuzzle = solvePuzzle;\nwindow.setPreset = setPreset;\nwindow.savePuzzleData = savePuzzleData;\nwindow.loadPuzzleData = loadPuzzleData;\n\n// Expose some variables to global scope for ease of debugging\nwindow.Alpine = Alpine;\nwindow.store = Alpine.store;\nwindow.client = client;\nwindow.Client = Client;\nwindow.ArchipelagoPuzzle = ArchipelagoPuzzle;\nwindow.syncAPStatus = syncAPStatus;\nwindow.SaveData = SaveData;\nwindow.loadPuzzle = loadPuzzle;\n\nAlpine.start();\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./src/puzzles.js?");

/***/ }),

/***/ "./src/savedata.js":
/*!*************************!*\
  !*** ./src/savedata.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameSave\": () => (/* binding */ GameSave),\n/* harmony export */   \"getFile\": () => (/* binding */ getFile),\n/* harmony export */   \"getFileList\": () => (/* binding */ getFileList),\n/* harmony export */   \"openDatabase\": () => (/* binding */ openDatabase)\n/* harmony export */ });\n/**\n * @template T\n * @param {{result: T}} transaction \n * @returns {Promise<T>}\n */\nfunction asPromise(transaction) {\n    return new Promise(function (resolve, reject) {\n        transaction.onsuccess = (e => resolve(transaction.result));\n        transaction.onerror = (e => reject(transaction.error));\n    })\n}\n\n/**\n * template T\n * @param {IDBRequest<IDBCursor | null>} transaction\n */\nasync function* asIterator(transaction) {\n    let cursor;\n    do {\n        cursor = await asPromise(transaction);\n\n        if (cursor) {\n            yield cursor;\n\n            cursor.continue();\n        }\n    } while (cursor)\n}\n\n/**\n * @type {IDBDatabase}\n */\nlet db;\n\nclass GameSave {\n    constructor(options) {\n        options ??= {};\n\n        this.id = options.id ?? null;\n        this.host = options.host ?? \"\";\n        this.port = options.port ?? 0;\n        this.player = options.player ?? \"\";\n        this.baseSeed = \"\" + (options.baseSeed ?? \"\");\n\n        this.solveTarget = options.solveTarget ?? null;\n\n        /**\n         * List of puzzle parameter strings, as provided by the Archipelago world.\n         * @type {string[]}\n         */\n        this.puzzles = options.puzzles ?? [];\n\n        /**\n         * Solved status of puzzles.\n         * @type {boolean[]}\n         */\n        this.puzzleSolved = options.puzzleSolved ?? Array(this.puzzles.length).fill(false)\n\n        /**\n         * Locked status of puzzles.\n         * @type {boolean[]}\n         */\n        this.puzzleLocked = options.puzzleLocked ?? Array(this.puzzles.length).fill(true)\n    }\n\n    async save() {\n        if (this.id == -1) return;\n\n        const transaction = db.transaction(\"gamesave\", \"readwrite\");\n        const gamesave = transaction.objectStore(\"gamesave\");\n\n        let obj = this.toObject();\n        if (obj.id === null) {\n            delete obj.id;\n        }\n\n        let key = await asPromise(gamesave.put(obj));\n\n        if (this.id === null) {\n            this.id = key\n        }\n\n        transaction.commit();\n    }\n\n    async getPuzzleSave(puzzleId) {\n        if (this.id == -1) return;\n\n        const transaction = db.transaction(\"puzzlesave\");\n        const puzzlesave = transaction.objectStore(\"puzzlesave\");\n\n        let obj = await asPromise(puzzlesave.get([this.id, puzzleId]));\n\n        if (obj) {\n            return obj.data;\n        } else {\n            return null;\n        }\n    }\n\n    async setPuzzleSave(puzzleId, data) {\n        if (this.id == -1) return;\n\n        const transaction = db.transaction(\"puzzlesave\", \"readwrite\");\n        const puzzlesave = transaction.objectStore(\"puzzlesave\");\n\n        let obj = {gameId: this.id, puzzleId: puzzleId, data: data};\n\n        await asPromise(puzzlesave.put(obj));\n\n        return;\n    }\n\n    async deleteFile() {\n        if (this.id == -1) return;\n\n        const transaction = db.transaction([\"gamesave\",\"puzzlesave\"], \"readwrite\");\n        const gamesave = transaction.objectStore(\"gamesave\");\n        const puzzlesave = transaction.objectStore(\"puzzlesave\");\n\n        let toAwait = [];\n\n        const puzzlesByGameId = puzzlesave.index(\"gameId\")\n\n        let puzzleIterator = asIterator(puzzlesByGameId.openCursor(this.id))\n\n        for await (let cursor of puzzleIterator) {\n            toAwait.push(cursor.delete());\n        }\n\n        toAwait.push(asPromise(gamesave.delete(this.id)));\n\n        transaction.commit();\n\n        await Promise.allSettled(toAwait);\n\n        return;\n    }\n\n    toString() {\n        return `${this.player} (${this.host}:${this.port}), ${this.puzzles.length} puzzles`;\n    }\n\n    toObject() {\n        return {\n            id: this.id,\n            host: this.host,\n            port: this.port,\n            player: this.player,\n            baseSeed: this.baseSeed,\n            puzzles: this.puzzles.slice(),\n            puzzleSolved: this.puzzleSolved.slice(),\n            puzzleLocked: this.puzzleLocked.slice(),\n            solveTarget: this.solveTarget\n        };\n    }\n\n    static fromObject(obj) {\n        return new GameSave(obj);\n    }\n}\n\nasync function openDatabase() {\n    let dbOpenReq = indexedDB.open(\"ap-puzzles\", 1);\n\n    dbOpenReq.onupgradeneeded = function(event) {\n        let db = dbOpenReq.result;\n\n        console.log(\"Creating indexedDB stores\")\n\n        if (event.oldVersion < 1) {\n            let gamesave = db.createObjectStore(\"gamesave\", {keyPath: \"id\", autoIncrement: true});\n            let puzzlesave = db.createObjectStore(\"puzzlesave\", {keyPath: [\"gameId\",\"puzzleId\"]});\n\n            puzzlesave.createIndex(\"gameId\", \"gameId\")\n        }\n    };\n\n    db = await asPromise(dbOpenReq);\n}\n\nasync function getFileList() {\n    let transaction = db.transaction(\"gamesave\");\n    let gamesave = transaction.objectStore(\"gamesave\");\n\n    let fileList = await asPromise(gamesave.getAll());\n\n    fileList = fileList.map(e => GameSave.fromObject(e));\n\n    return fileList;\n}\n\nasync function getFile(id) {\n    return new GameSave.fromObject();\n}\n\n//# sourceURL=webpack://ap-sgtpuzzles-web/./src/savedata.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/puzzles.js");
/******/ 	
/******/ })()
;